<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bruceeezhao.github.io/"/>
  <updated>2020-03-06T13:24:18.759Z</updated>
  <id>https://bruceeezhao.github.io/</id>
  
  <author>
    <name>bruce zhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>智能计算系统</title>
    <link href="https://bruceeezhao.github.io/2020/03/06/%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E7%B3%BB%E7%BB%9F/"/>
    <id>https://bruceeezhao.github.io/2020/03/06/智能计算系统/</id>
    <published>2020-03-06T11:21:19.000Z</published>
    <updated>2020-03-06T13:24:18.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><h2 id="1-1-三个流派"><a href="#1-1-三个流派" class="headerlink" title="1.1. 三个流派"></a>1.1. 三个流派</h2><a id="more"></a><ul><li>行为主义： 基于控制论，构建感知-动作控制系统</li><li>符号注意： 基于符号逻辑的方法，用逻辑表示知识和求解问题</li><li>连接主义： 基于大脑中神经元细胞连接的计算模型，用人工神经网络来拟合智能行为</li></ul><h2 id="1-2-智能计算系统"><a href="#1-2-智能计算系统" class="headerlink" title="1.2. 智能计算系统"></a>1.2. 智能计算系统</h2><p>是智能的物质载体，现阶段通常是集成CPU和智能芯片的异构系统，软件上通常包括一套面向开发者的智能计算编程环境（包括编程框架和编程语言）。</p><ul><li>异构只能计算系统的主要原因：<br>通用CPU的计算能力增长近乎停滞，而智能计算能力的需求不断增长。</li><li>异构系统在提高性能的同时，也带来了编程上的困难<ul><li>一般包括一套编程框架</li></ul></li></ul><h2 id="1-3-三代智能计算系统"><a href="#1-3-三代智能计算系统" class="headerlink" title="1.3. 三代智能计算系统"></a>1.3. 三代智能计算系统</h2><ul><li>第一代： 1980年代，面向服好主意智能处理的专用计算机（Prolog机，LISP机）</li><li>第二代： 2010年代，面向连接注意智能处理的专用计算机（深度学习计算机）</li><li>第三代： 未来强人工智能/通用人工智能的载体</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;h2 id=&quot;1-1-三个流派&quot;&gt;&lt;a href=&quot;#1-1-三个流派&quot; class=&quot;headerlink&quot; title=&quot;1.1. 三个流派&quot;&gt;&lt;/a&gt;1.1. 三个流派&lt;/h2&gt;
    
    </summary>
    
      <category term="智能计算系统" scheme="https://bruceeezhao.github.io/categories/%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>创业基础-2.如何创业</title>
    <link href="https://bruceeezhao.github.io/2020/02/25/%E5%88%9B%E4%B8%9A%E5%9F%BA%E7%A1%80-2-%E5%A6%82%E4%BD%95%E5%88%9B%E4%B8%9A/"/>
    <id>https://bruceeezhao.github.io/2020/02/25/创业基础-2-如何创业/</id>
    <published>2020-02-25T08:03:50.000Z</published>
    <updated>2020-02-25T11:30:52.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="成为创业者"><a href="#成为创业者" class="headerlink" title="成为创业者"></a>成为创业者</h1><p>##　创业能力</p><a id="more"></a><ol><li>创业思维</li><li>应变能力</li><li>拓展资源的能力</li><li>合作能力</li><li>自我反省的能力</li><li>冒险精神</li><li>社会责任</li></ol><h2 id="创业者素质"><a href="#创业者素质" class="headerlink" title="创业者素质"></a>创业者素质</h2><ol><li>领袖精神</li><li>自信</li><li>勇气</li><li>创新精神</li><li>魄力</li><li>敏锐眼光</li><li>毅力和意志</li><li>自我调节能力</li></ol><h1 id="认识创业机会"><a href="#认识创业机会" class="headerlink" title="认识创业机会"></a>认识创业机会</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>创业机会是具有商业价值的创意</strong>  </p><h2 id="创业机会的特征："><a href="#创业机会的特征：" class="headerlink" title="创业机会的特征："></a><strong>创业机会的特征：</strong></h2><ol><li>能吸引顾客，挖掘顾客的真实需求</li><li>在商业环境中行得通，有竞争力</li><li>在机会之床存在的期间被实施。（机会之窗指在商业想法推广到市场上去所话的时间，若竞争者已经有了同样的思想，并吧产品已推向市场，那么机会之窗也就关闭了。）</li><li>创业者必须有资源和技能才能创立业务，这里的资源包括：人、财、物、信息和时间等。</li></ol><h2 id="创业机会的类型"><a href="#创业机会的类型" class="headerlink" title="创业机会的类型"></a>创业机会的类型</h2><ul><li>问题型</li><li>趋势型</li><li>组合型</li></ul><h2 id="机会识别方法"><a href="#机会识别方法" class="headerlink" title="机会识别方法"></a>机会识别方法</h2><ul><li>问题分心</li><li>创造需求</li></ul><h2 id="创业机会评价"><a href="#创业机会评价" class="headerlink" title="创业机会评价"></a>创业机会评价</h2><p>基本标准：</p><ol><li>机会对产品有明确界定的市场需求，退出的实际也是恰当的</li><li>投资的项目必须能够维持持久的竞争优势</li><li>投资必须具有一定成都的高汇报，从而允许一些投资中的失误</li><li>创业者和创业机会时间必须相互适应</li><li>创业机会中不存在致命的缺陷</li></ol><h1 id="组建创业团队"><a href="#组建创业团队" class="headerlink" title="组建创业团队"></a>组建创业团队</h1><h2 id="团队组建"><a href="#团队组建" class="headerlink" title="团队组建"></a>团队组建</h2><ol><li>自我评估</li></ol><ul><li>知识基础</li><li>专门技能</li><li>动机</li><li>承诺</li><li>个人特质</li></ul><ol start="2"><li>成员评估</li></ol><ul><li>互补性</li><li>相似性</li></ul><p>在知识、技能和经验方面主要关注互补性，而在个人特征和动机方面则考虑相似性。</p><ol><li>知识评估</li><li>经历评估</li><li>经验评估</li><li>关系评估</li><li>能力评估</li></ol><h2 id="行动原则"><a href="#行动原则" class="headerlink" title="行动原则"></a>行动原则</h2><ol><li>创业机会</li><li>凝聚力</li><li>合作精神</li><li>完整性（利弊权衡）</li><li>长远目标</li><li>价值创造</li><li>公正性</li></ol><h2 id="创业团队的领导"><a href="#创业团队的领导" class="headerlink" title="创业团队的领导"></a>创业团队的领导</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;成为创业者&quot;&gt;&lt;a href=&quot;#成为创业者&quot; class=&quot;headerlink&quot; title=&quot;成为创业者&quot;&gt;&lt;/a&gt;成为创业者&lt;/h1&gt;&lt;p&gt;##　创业能力&lt;/p&gt;
    
    </summary>
    
      <category term="创业基础" scheme="https://bruceeezhao.github.io/categories/%E5%88%9B%E4%B8%9A%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>大数据系统</title>
    <link href="https://bruceeezhao.github.io/2020/02/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/"/>
    <id>https://bruceeezhao.github.io/2020/02/19/大数据系统/</id>
    <published>2020-02-19T13:13:57.000Z</published>
    <updated>2020-03-06T11:20:53.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><h2 id="1-1-大数据概念"><a href="#1-1-大数据概念" class="headerlink" title="1.1. 大数据概念"></a>1.1. 大数据概念</h2><a id="more"></a><p><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/concept.png" alt="概念"></p><h2 id="1-2-大数据管理系统"><a href="#1-2-大数据管理系统" class="headerlink" title="1.2. 大数据管理系统"></a>1.2. 大数据管理系统</h2><ul><li>关系型<br>Oracle, DB2, MS SQL Server, Greenplum, TeraData, Vertica</li><li>云平台<br>MapReduce, Apache Hadoop, MS Dryad</li><li>云平台+SQL<br>Apache Hive, Yahoo Pig, MS Scope</li><li>No-SQL<br>Apache Hbase, Cassandra, MangoDB, Neo4j</li><li>内存数据处理系统<br>MMDB, Spark, Cloudera impala</li><li>图数据处理<br>Google Pregel, Apache Giraph, Graphlab</li></ul><h1 id="2-关系型数据管理系统"><a href="#2-关系型数据管理系统" class="headerlink" title="2. 关系型数据管理系统"></a>2. 关系型数据管理系统</h1><h2 id="2-1-关系型数据模型"><a href="#2-1-关系型数据模型" class="headerlink" title="2.1. 关系型数据模型"></a>2.1. 关系型数据模型</h2><p>Table/Relation</p><ul><li>列(Column)</li><li>行(Row)</li></ul><p>通常是一个瘦长的表</p><h3 id="2-1-1-概念"><a href="#2-1-1-概念" class="headerlink" title="2.1.1. 概念"></a>2.1.1. 概念</h3><h4 id="2-1-1-1-Schema-vs-Instance"><a href="#2-1-1-1-Schema-vs-Instance" class="headerlink" title="2.1.1.1. Schema vs. Instance"></a>2.1.1.1. Schema vs. Instance</h4><ul><li><p>Schema: 类型<br>一个表的类型是由每个列的类型决定的</p></li><li><p>Instance： 具体取值<br>具体存储哪些记录，每个列的具体指<br>由具体用用决定</p></li></ul><h4 id="2-1-1-2-Key"><a href="#2-1-1-2-Key" class="headerlink" title="2.1.1.2. Key"></a>2.1.1.2. Key</h4><ul><li>Primary key</li><li>Foreign key<br>是另一个表的主键</li></ul><h2 id="2-2-主要关系运算"><a href="#2-2-主要关系运算" class="headerlink" title="2.2. 主要关系运算"></a>2.2. 主要关系运算</h2><ul><li>Selection（选择）<br>从一个表中提取一些行</li><li>Projection(投影)<br>从一个表中提取一些列</li><li>Join（连接）<ul><li>Equi-join(等值连接)</li></ul></li></ul><h3 id="2-2-1-SQL-Selcet"><a href="#2-2-1-SQL-Selcet" class="headerlink" title="2.2.1. SQL Selcet"></a>2.2.1. SQL Selcet</h3><p><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/select.png" alt="select"></p><h2 id="2-3-数据库系统架构"><a href="#2-3-数据库系统架构" class="headerlink" title="2.3. 数据库系统架构"></a>2.3. 数据库系统架构</h2><p>通常的系统为典型的C/S结构：<br><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/RDBMS-CS.png" alt="CS"><br><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/RDBMS-S.png" alt="S"></p><ol><li>SQL Parser</li></ol><ul><li>SQL语句的程序 -&gt; 解析好的内部表达（例如：Parsing tree）<ul><li>语法解析，语法检查，表名、列名、类型检查</li></ul></li></ul><ol start="2"><li>Query Optimizer</li></ol><ul><li>SQL 内部表达 -&gt; Query Plan（执行方案）<ul><li>产生可行的query plan</li><li>估计query plan的运行时间和空间代价</li><li>在多个可行的query plans中选择最佳的query plan</li></ul></li></ul><ol start="3"><li>Data storage and indexing</li></ol><ul><li>如何在硬盘上存储数据</li><li>如何高效地访问硬盘上的数据</li></ul><ol start="4"><li><p>Buffer Pool：在内存中缓存硬盘的数据</p></li><li><p>Execution Engine</p></li></ol><ul><li>query plan -&gt; SQL语句的借故偶<ul><li>根据query plan，完成相应的运算和操作</li><li>数据访问</li><li>关系型运算的实现</li></ul></li></ul><ol start="6"><li>Transaction management</li></ol><ul><li>目标是实现ACID</li><li>进行logging写日志，locking加锁</li><li>保证并行transactions事务的正确性</li></ul><h2 id="2-4-数据存储与访问"><a href="#2-4-数据存储与访问" class="headerlink" title="2.4. 数据存储与访问"></a>2.4. 数据存储与访问</h2><h3 id="2-4-1-数据表（table）"><a href="#2-4-1-数据表（table）" class="headerlink" title="2.4.1. 数据表（table）"></a>2.4.1. 数据表（table）</h3><p><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/filevsdatabase.png" alt="filevsdb"></p><p>数据在硬盘上的存储：</p><ul><li>硬盘最小存储访问单位为一个山区： 512B</li><li>文件系统访问硬盘的单位通常为： 4KB</li><li>RDBMS最小的存储单位是database page size<ul><li>Data page size可以设置为1～多个文件系统的page</li><li>例如， 4KB、8KB …</li></ul></li></ul><p><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/page.png" alt="page"></p><p>page内部结构：<br><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/page-inner.png" alt="page-iner"></p><ul><li>page header:存储page的一些信息，例如page ID</li><li>slot：是一个定长整数数组，从后向前增长</li><li>记录：header和slot之间的空间，从前向后增长</li></ul><p><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/tuple.png" alt="tuple"><br><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/tuple-ex.png" alt="tuple-ex"></p><p>数据的顺序访问：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">Name</span>, GPA</span><br><span class="line"><span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> Major = <span class="string">'计算机'</span></span><br></pre></td></tr></table></figure><ul><li>顺序读取、student表的每个page</li><li>对于每个page，顺序访问每个tuple</li><li>检查条件是否成立</li><li>对于成立的读取Name和GPA</li></ul><p><strong>有什么性能问题吗？假如有100个系呢?</strong>  </p><h3 id="2-4-2-索引（index）"><a href="#2-4-2-索引（index）" class="headerlink" title="2.4.2. 索引（index）"></a>2.4.2. 索引（index）</h3><p>Selective Data Access(有选择性的访问)</p><ul><li>使用Index<ul><li>Tree based index:有序，支持点查询和范围查询</li><li>Hash based index：无序，只支持点查询</li></ul></li><li>Clustered index(主索引)与Secondary index(二级索引)<ul><li>Clustered: 记录就存在index中，记录顺序就是index顺序</li><li>Secondary: 记录顺序不是index顺序，index中存储page ID和in-page tuple slot ID.</li></ul></li></ul><ol><li>Chained Hash Table:<br><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/chainhashtabe.png" alt="chainhasht"></li></ol><p><strong>在硬盘上怎么存？</strong><br>bucket = page<br>当chain上平均bucket数太多是，需要增大size，重新hashing。<br><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/chainhash-ex.png" alt="chainhash-ex"></p><ol start="2"><li>B+ Tree<br><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/B+tree.png" alt="B+tree"></li></ol><ul><li>所有的叶子结点都位于同一层</li><li>每个叶子节点是一个page</li><li>所有key存储在叶子节点</li><li>内部节点完全是索引作用</li></ul><p>叶子节点结构：<br><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/B+leaf.png" alt="leaf"></p><ul><li>Keys按照从小到达顺序排列： key1 &lt; key2 &lt; … &lt; keyn</li><li>叶子节点从左向有也是从小到达顺序排列，以sibling pointer链起来(ptr = record ID; sibling = page ID)</li></ul><p>Search代价：</p><ul><li>共有N个key</li><li>每个节点的child/pointer个数为B</li><li>总I/O次数=树高  $O(log_B N)$</li><li>总比较次数<ul><li>每个节点内部二分查找： $O(log_2 B)$</li><li>$O(log_B N)*O(log_2 B) = O(log_2 N)$</li></ul></li></ul><p>删除操作：</p><ul><li>Search 人后在节点中删除</li><li>node merge？<ul><li>原设计：当节点中key个数小于一把</li><li>实际实现：数据总趋势是增长的，可以只有节点为空是才node merge或者完全不进行node merge</li></ul></li></ul><p>Range Scan：</p><ul><li>找到其实叶节点，包括范围起始值</li><li>沿着叶的链接读下一个叶节点</li><li>直到遇到范围终止值</li></ul><p><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/rangescan.png" alt="rangescan"></p><ol start="3"><li>二级索引<br>假设已经建立了以Major为key的二级索引<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">Name</span>, GPA</span><br><span class="line"><span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> Major = <span class="string">'计算机'</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>在二级索引中搜索 Major = ‘计算机’</li><li>对于每个匹配项，访问相应的tuple</li><li>读取Name和GPA</li></ul><p><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/secondaryvssequ.png" alt="secondary"></p><h3 id="2-4-3-缓冲池（buffer-pool）"><a href="#2-4-3-缓冲池（buffer-pool）" class="headerlink" title="2.4.3. 缓冲池（buffer pool）"></a>2.4.3. 缓冲池（buffer pool）</h3><p><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/bufferpool.png" alt="buffer"></p><p>数据访问的局部性：</p><ul><li><p>Temporal locality(时间局部性)</p><ul><li>同一个数据元素可能会在一段时间内多次被访问</li><li>buffer pool</li></ul></li><li><p>Spatial locality(空间局部性)</p><ul><li>位置相近的数据元素可能会被一起访问</li><li>Page 为单位读写</li></ul></li></ul><p>访问page的过程：</p><ul><li><p>检查Page a是否在buffer pool中</p></li><li><p>是：buffer pool hit</p><ul><li>直接访问buffer pool中的page a</li></ul></li><li><p>否： buffer pool miss</p><ul><li>在buffer pool中找到一个可用的frame</li><li>从硬盘读page a，放入这个frame</li></ul></li></ul><h4 id="2-4-3-1-缓存替换算法"><a href="#2-4-3-1-缓存替换算法" class="headerlink" title="2.4.3.1 缓存替换算法"></a>2.4.3.1 缓存替换算法</h4><ul><li>LRU（Least Recently Used）</li><li>Random</li><li>FIFO</li><li>Clock</li></ul><p>数据库中使用Clock算法：</p><p><a href="https://www.cnblogs.com/wingsless/p/12295246.html" target="_blank" rel="noopener">引用自</a><br>时钟置换算法可以认为是一种最近未使用算法，即逐出的页面都是最近没有使用的那个。我们给每一个页面设置一个标记位u，u=1表示最近有使用u=0则表示该页面最近没有被使用，应该被逐出。<br>按照1-2-3-4的顺序访问页面，则缓冲池会以这样的一种顺序被填满：<br><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/clock1.png" alt="clock1"><br>此时如果要按照1-5的顺序访问，那么在访问1的时候是可以直接命中缓存返回的，但是访问5的时候，因为缓冲池已经满了，所以要进行一次逐出操作，其操作示意图如下：<br><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/clock2.png" alt="clock2"><br>每次遍历到一个节点发现u=1的，将该标记位置为0，然后遍历下一个页面，一轮遍历完后，发现没有可以被逐出的页面，则进行下一轮遍历，这次遍历之后发现原先1号页面的标记位u=0，则将该页面逐出，置换为页面5，并将指针指向下一个页面。<br>但是考虑一个问题，数据库里逐出的页面是要写回磁盘的，这是一个很昂贵的操作，因此我们应该优先考虑逐出那些没有被修改的页面，这样可以降低IO。  </p><p>因此在时钟置换算法的基础上可以做一个改进，就是增加一个标记为m，修改过标记为1，没有修改过则标记为0。那么u和m组成了一个元组，有四种可能，其被逐出的优先顺序也不一样：  </p><ul><li>(u=0, m=0) 没有使用也没有修改，被逐出的优先级最高；</li><li>(u=1, m=0) 使用过，但是没有修改过，优先级第二；</li><li>(u=0, m=1) 没有使用过，但是修改过，优先级第三；</li><li>(u=1, m=1) 使用过也修改过，优先级第四。</li></ul><p><a href="https://www.cnblogs.com/claudia529/p/12088532.html" target="_blank" rel="noopener">引用自</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">U为访问位，M为修改位。</span><br><span class="line">1.当U=0,M=0。表示既没被访问，也没被修改。 是最佳淘汰页。</span><br><span class="line">2.当U=0,M=1。表示没访问但是修改了。 不是很好的淘汰页。</span><br><span class="line">3.当U=1,M=0。表示已访问，没有修改。有可能再被访问。</span><br><span class="line">4.当U=1,M=1。访问且修改。有可能再被访问。</span><br><span class="line">一、先找U=0,M=0的。并将遇到的第一个页面作为选中的淘汰页。第一次扫描期间不改变访问位A。</span><br><span class="line">二、第一步失败则U=0,M=1作为淘汰页面。第二轮扫描期间把所有扫描过的页面访问位置0。</span><br><span class="line">三、指针回到最初的位置,然后重复第一步（找A=0，M=0）失败的话重复第二步（A=0，M=1）</span><br><span class="line">减少磁盘的I/O操作次数。但是可能经过几轮扫描，即可以拆解为算法本身的开销有所增加。</span><br></pre></td></tr></table></figure><h2 id="2-5-运算的实现"><a href="#2-5-运算的实现" class="headerlink" title="2.5. 运算的实现"></a>2.5. 运算的实现</h2><h3 id="2-5-1-Operator-tree"><a href="#2-5-1-Operator-tree" class="headerlink" title="2.5.1. Operator tree"></a>2.5.1. Operator tree</h3><p><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/operatortree.png" alt="operator tree"></p><ul><li><p>Query plan 最终将表现为一棵Operator Tree</p><ul><li>每个节点代表一个运算</li><li>运算的输入来自孩子节点</li><li>运算的输出送往父亲节点</li></ul></li><li><p>实现方法</p><ul><li>Operator at a time<ul><li>完全处理一个运算在处理下一个运行，会产生大量中间结果</li></ul></li><li>Pull(Tuple at a time)<ul><li>每个Operator实现Open, Close, GetNext方法</li><li>父节点调用子节点的GetNext() 取得下一个子节点的输出</li></ul></li><li>Push： 多线程<ul><li>子节点吧输出放入中间结果缓冲，然后通知父节点去读</li></ul></li></ul></li></ul><h3 id="2-5-2-Selection-amp-Projection"><a href="#2-5-2-Selection-amp-Projection" class="headerlink" title="2.5.2. Selection &amp; Projection"></a>2.5.2. Selection &amp; Projection</h3><ul><li><p>Selection： 行的过滤</p><ul><li>支持多种数据类型：数值类型，字符串类型等</li><li>实现比较操作、数学运算、逻辑运算</li></ul></li><li><p>Projection： 列的提取</p><ul><li>Query plan生成时，同时产生中间结果记录的schema</li><li>主要功能： 从一个记录中提取属性，生成一个结果记录</li></ul></li></ul><h3 id="2-5-3-Join"><a href="#2-5-3-Join" class="headerlink" title="2.5.3. Join"></a>2.5.3. Join</h3><p>实现思路：</p><ul><li>Nested loop</li><li>Hashing</li><li>Sorting</li></ul><ol><li><p>Nested loop<br><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/nested-loop-join-e1.png" alt="nest"><br><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/nested-loop-join-io.png" alt="nest-io"><br><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/nested-loop-join-e1.png" alt="nest-e1"><br><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/nested-loop-join-e2.png" alt="nest-e2"></p></li><li><p>Hashing<br><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/hash-join.png" alt="hash"><br>如果遇到R比内存大应该怎么办？<br><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/hash-loop-q1.png" alt="hash-q1"></p></li></ol><ul><li>GRACE Hash join<br><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/grace-hash-join.png" alt="grace"><br><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/grace-hash-join-x.png" alt="grace-io"></li></ul><ol start="3"><li>sort merge join</li></ol><ul><li>思路：<ul><li>如果把R按照R.a的顺序排序</li><li>如果把S按照S.b的顺序排序</li><li>那么可以Merge（归并）找出所有的匹配</li></ul></li></ul><p><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/sort-merge-io.png" alt="sort-io"></p><ul><li>比较：<ul><li>通常代价比Hash Join稍差</li><li>当一个表已经有序的情况下，会被使用</li></ul></li></ul><h2 id="2-6-Query-Optimization（查询优化）"><a href="#2-6-Query-Optimization（查询优化）" class="headerlink" title="2.6. Query Optimization（查询优化）"></a>2.6. Query Optimization（查询优化）</h2><p><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/query-optimization.png" alt="query"></p><h2 id="2-7-事务处理-Transaction-Processing"><a href="#2-7-事务处理-Transaction-Processing" class="headerlink" title="2.7. 事务处理(Transaction Processing)"></a>2.7. 事务处理(Transaction Processing)</h2><p>大量并发用户，少量随机读写操作</p><ul><li>一个事务可能包含多个操作<ul><li>select</li><li>insert/delete/update</li><li>等</li></ul></li><li>事务中的所有操作满足ACID性质</li></ul><p>事务的表现形式：</p><ol><li>没有特殊设置<br>那么每个SQL语句被认为是一个事务</li><li>使用特殊的语句</li></ol><ul><li>开始transaction</li><li>成功结束transaction</li><li>异常结束transaction</li></ul><h3 id="2-7-1-ACID"><a href="#2-7-1-ACID" class="headerlink" title="2.7.1. ACID"></a>2.7.1. ACID</h3><ul><li>Atomicity（原子性）<ul><li>all or nothing</li><li>要么完全执行，要么完全没有执行</li></ul></li><li>Consistency（一致性）<ul><li>从一个正确状态转换到另一个正确状态（正确指：constraints, triggers等）</li></ul></li><li>Isolation（隔离性）<ul><li>每个事务与其它并发事务互不影响</li></ul></li><li>Durability（持久性）<ul><li>Transaction commit后，结果持久有效，crash也不消失</li></ul></li></ul><h3 id="2-7-2-Concurrency-Control-并发控制后"><a href="#2-7-2-Concurrency-Control-并发控制后" class="headerlink" title="2.7.2. Concurrency Control(并发控制后)"></a>2.7.2. Concurrency Control(并发控制后)</h3><h4 id="2-7-2-1-数据冲突引起的问题："><a href="#2-7-2-1-数据冲突引起的问题：" class="headerlink" title="2.7.2.1. 数据冲突引起的问题："></a>2.7.2.1. 数据冲突引起的问题：</h4><ul><li>Read uncommitted data (读脏数据) (写读)<ul><li>在T2 commit之前，T1读了T2已经修改了的数据</li></ul></li><li>Unrepeatable reads(不可重复读) (读写)<ul><li>在T2 commit之前，T1写了T2已经读的数据</li><li>如果T2再次读同一个数据，那么将发现不同的值</li></ul></li><li>Overwrite uncommitted data (更新丢失) (写写)<ul><li>在T2 commit之前，T1重写了T2已经修改了的数据</li></ul></li></ul><p><strong>两大类解决方案：</strong>  </p><ul><li><p>Pessimistic (悲观)</p><ul><li>假设：数据竞争可能经常出现</li><li>防止：采用某种机制保证数据竞争不会出现 – 如果一个Transaction T1可能和正在运行的其它Transaction有冲突，那么就让这个T1等待，一直等到有冲突的其它所有Transaction都完成为止，才开始执行。</li></ul></li><li><p>Optimistic (乐观)</p><ul><li>假设：数据竞争很少见</li><li>检查：先执行，在提交前检查是否没有数据竞争 <ul><li>允许所有Transaction都直接执行 </li><li>但是Transaction不直接修改数据，而是把修改保留起来 </li><li>当Transaction结束时，检查这些修改是否有数据竞争<ul><li>没有竞争，成功结束，真正修改数据</li><li>有竞争，丢弃结果，重新计算</li></ul></li></ul></li></ul></li></ul><h4 id="2-7-2-2-悲观解决方案"><a href="#2-7-2-2-悲观解决方案" class="headerlink" title="2.7.2.2. 悲观解决方案"></a>2.7.2.2. 悲观解决方案</h4><p><strong>Pessimistic: 加锁</strong></p><ul><li>使用加锁协议来实现</li><li>对于每个事务中的SQL语句，数据库系统自动检测其中的读、写的数据</li><li>对事务中的读写数据进行加锁</li><li>通常采用两阶段加锁（2 Phase Locking）</li></ul><p><strong>2 Phase Locking</strong></p><ul><li>Pessimistic concurrency control</li><li>对每个访问的数据都要加锁后才能访问</li><li>算法如下<ul><li>在Transaction开始时，对每个需要访问的数据加锁 – 如果不能加锁，就等待，直到加锁成功</li><li>执行Transaction的内容</li><li>在Transaction commit前，集中进行解锁</li><li>Commit</li></ul></li><li>有一个集中的加锁阶段和一个集中的解锁阶段<ul><li>由此得名</li></ul></li></ul><p><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/lock-achive-1.png" alt="lock-1"></p><p><strong>实现细节2： Lock Granularity</strong>  </p><ul><li>锁的粒度是不同的<ul><li>Table?</li><li>Record?</li><li>Index?</li><li>Leaf node?</li></ul></li><li>Intent locks<ul><li>IS(a)：将对a下面更细粒度的数据元素进行读</li><li>IX(a)：将对a下面更细粒度的数据元素进行写</li></ul></li><li>为了得到S,IS: 所有祖先必须为IS或IX</li><li>为了得到X,IX: 所有祖先必须为IX</li></ul><p><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/lock-achive-2.png" alt="lock-2"></p><p><strong>实现细节3： deadlock</strong><br><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/lock-achive-3.png" alt="lock-3"></p><p><strong>如何解决deadlock问题？</strong>  </p><ul><li><p>死锁避免</p><ul><li>规定lock对象的顺序</li><li>按照顺序请求lock</li><li>适用于lock对象少的情况</li></ul></li><li><p>数据库的lock对象很多，不适合死锁避免</p></li><li><p>死锁检测</p><ul><li>周期地对长期等待的Transactions检查是否有circular wait</li><li>如果有，那么就选择环上其中一Transaction abort</li></ul></li></ul><h4 id="2-7-2-3-乐观的并发控制：不采用加锁"><a href="#2-7-2-3-乐观的并发控制：不采用加锁" class="headerlink" title="2.7.2.3. 乐观的并发控制：不采用加锁"></a>2.7.2.3. 乐观的并发控制：不采用加锁</h4><ul><li>事务执行分为三个阶段<ul><li>读：事务开始执行，读数据到私有工作区，并在私有工作区上完成事务的处理请求，完成修改操作</li><li>验证：如果事务决定提交，检查事务是否与其它事务冲突 – 如果存在冲突，那么终止事务，清空私有工作区 – 重试事务</li><li>写：验证通过，没有发现冲突，那么把私有工作区的修改<br>复制到数据库公共数据中</li></ul></li><li>优点：当冲突很少时，没有加锁的开销</li><li>缺点：当冲突很多时，可能不断地重试，浪费大量资源，甚至无法前进</li></ul><p><strong>另一种并发控制方法:Snapshot Isolation</strong>  </p><ul><li>一种Optimistic concurrency control</li><li>Snapshot: 一个时点的数据库数据状态</li><li>Transaction<ul><li>在起始时点的snapshot</li><li>读：这个snapshot的数据</li><li>写：先临时保存起来，在commit时检查有无冲突，有冲突就abort<ul><li>First writer wins</li></ul></li></ul></li></ul><p><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/snapshot-isolation.png" alt="snapshot"><br><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/snapshot-special.png" alt="snapshot-s"></p><h3 id="2-7-3-Crash-Recovery-崩溃恢复"><a href="#2-7-3-Crash-Recovery-崩溃恢复" class="headerlink" title="2.7.3. Crash Recovery(崩溃恢复)"></a>2.7.3. Crash Recovery(崩溃恢复)</h3><h4 id="2-7-3-1-Durability-持久性-如何实现？"><a href="#2-7-3-1-Durability-持久性-如何实现？" class="headerlink" title="2.7.3.1. Durability (持久性) 如何实现？"></a>2.7.3.1. Durability (持久性) 如何实现？</h4><ul><li>Transaction commit后，结果持久有效，crash不消失</li><li>想法一<ul><li>在transaction commit时，把所有的修改都写回硬盘</li><li>只有当写硬盘完成后，才commit</li></ul></li><li>有什么问题？<ul><li>正确性问题：如果写多个page，中间掉电，怎么办？<br>Atomicity被破坏了！</li><li>性能问题：随机写硬盘，等待写完成</li></ul></li></ul><p>解决方案：WAL (Write Ahead Logging)</p><ul><li>什么是Logging</li><li>什么是Write-Ahead<ul><li>Logging 总是先于实际的操作</li><li>Logging 相当于意向，先记录意向，然后再实际操作</li></ul></li><li>怎样保证Durability</li><li>怎么实现Write-Ahead Logging</li><li>Crash Recovery</li></ul><p><strong>Checkpoint:</strong>  </p><ul><li>为什么要用checkpoint?<ul><li>为了使崩溃恢复的时间可控</li><li>如果没有checkpoint，可能需要读整个日志，redo/undo很多工作</li></ul></li><li>定期执行checkpoint</li><li>checkpoint的内容<ul><li>当前活动的事务表：包括事务的最新日志的LSN</li><li>当前脏页表：每个页最早的尚未写回硬盘的LSN</li></ul></li></ul><h4 id="2-7-3-2-崩溃恢复"><a href="#2-7-3-2-崩溃恢复" class="headerlink" title="2.7.3.2. 崩溃恢复"></a>2.7.3.2. 崩溃恢复</h4><ol><li>分析阶段</li></ol><ul><li>找到最后一个检查点<ul><li>检查点的位置记录在硬盘上一个特定文件中</li><li>读这个文件，可以得知最后一个检查点的位置</li></ul></li><li>找到日志崩溃点<ul><li>如果是掉电等故障，必须找到日志的崩溃点</li><li>当日志是循环写时，需要从检查点扫描日志，检查每个日志页的校验码，发现校验码出错的位置，或者LSN变小的位置</li></ul></li><li>确定崩溃时的活跃事务和脏页<ul><li>最后一个检查点时的活跃事务表和脏页表</li><li>正向扫描日志，遇到commit, rollback, begin更新事务表 – 同时记录每个活动事务的最新LSN</li><li>遇到写更新脏页表 – 同时记录每个页的最早尚未写回硬盘的LSN</li></ul></li></ul><ol start="2"><li>Redo阶段</li></ol><ul><li>目标：把系统恢复到崩溃前瞬间的状态</li><li>找到所有脏页的最早的LSN</li><li>从这个LSN向日志尾正向读日志<ul><li>Redo每个日志修改记录</li></ul></li><li>对于一个日志记录<ul><li>如果其涉及的页不在脏页表中，那么跳过</li><li>如果数据页的LSN&gt;=日志的LSN，那么跳过 – 数据页已经包含了这个修改</li><li>其它情况，修改数据页</li></ul></li></ul><ol start="3"><li>Undo阶段</li></ol><ul><li>目标：清除未提交的事务的修改</li><li>对于所有在崩溃时活跃的事务<ul><li>找到这个事务最新的LSN</li><li>通过反向链表，读这个事务的所有日志记录</li></ul></li><li>undo所有未提交事务的修改<ul><li>Undo时，比较数据页的LSN和日志的LSN</li><li>if (数据页LSN&gt;=日志LSN) 时，才进行undo</li></ul></li></ul><h2 id="2-8-数据仓库"><a href="#2-8-数据仓库" class="headerlink" title="2.8. 数据仓库"></a>2.8. 数据仓库</h2><h3 id="2-8-1-OLAP"><a href="#2-8-1-OLAP" class="headerlink" title="2.8.1. OLAP"></a>2.8.1. OLAP</h3><h3 id="2-8-2-行式与列式数据库"><a href="#2-8-2-行式与列式数据库" class="headerlink" title="2.8.2. 行式与列式数据库"></a>2.8.2. 行式与列式数据库</h3><p>列式存储：</p><ul><li>数据仓库的分析查询<ul><li>大部分情况只涉及一个表的少数几列</li><li>会读一大部分记录</li></ul></li><li>在这种情况下，行式存储需要读很多无用的数据</li><li>采用列式存储可以降低读的数据量</li></ul><p>列式存储的压缩</p><ul><li>每个文件存储相同数据类型的值</li><li>数据更容易被压缩</li><li>比行式存储有更高的压缩比</li></ul><p>列式存储的问题</p><ul><li>如果用到了一个表的多个列</li><li>太多列拼装在一起，付出拼装代价很大</li></ul><h2 id="2-9-分布式数据库"><a href="#2-9-分布式数据库" class="headerlink" title="2.9. 分布式数据库"></a>2.9. 分布式数据库</h2><h3 id="2-9-1-系统架构"><a href="#2-9-1-系统架构" class="headerlink" title="2.9.1. 系统架构"></a>2.9.1. 系统架构</h3><p>三种架构</p><ul><li>Shared memory<ul><li>多芯片、多核</li><li>或Distributed shared memory</li></ul></li><li>Shared disk<ul><li>多机连接相同的数据存储设备</li></ul></li><li>Shared nothing<ul><li>普通意义上的机群系统</li><li>由以太网连接多台服务器<br><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/shared-nothing.png" alt="shared-nothing"></li></ul></li></ul><p>关键技术</p><ul><li><p>Partitioning（划分）</p><ul><li>把数据分布在多台服务器上</li><li>通常采用Horizontal partitioning – 把不同的记录分布在不同的服务器上</li></ul></li><li><p>Replication（备份）</p><ul><li>为了提高可靠性</li><li>对性能的影响 <ul><li>读？可能提高并行性 </li><li>写？额外代价</li></ul></li></ul></li><li><p>Hash partitioning</p><ul><li>类似GRACE: machine ID = hash(key) % MachineNumber</li></ul></li><li><p>Range partitioning</p><ul><li>每台服务器负责一个key的区间，所有区间都不重叠</li></ul></li></ul><h3 id="2-9-2-分布式查询处理"><a href="#2-9-2-分布式查询处理" class="headerlink" title="2.9.2. 分布式查询处理"></a>2.9.2. 分布式查询处理</h3><h3 id="2-9-3-分布式事务处理"><a href="#2-9-3-分布式事务处理" class="headerlink" title="2.9.3. 分布式事务处理"></a>2.9.3. 分布式事务处理</h3><h4 id="2-9-3-1-2-Phase-Commit"><a href="#2-9-3-1-2-Phase-Commit" class="headerlink" title="2.9.3.1. 2 Phase Commit"></a>2.9.3.1. 2 Phase Commit</h4><ul><li>Participant: 完成分布式事务的部分读写操作</li><li>Coordinator: 协调分布式事务的进行</li></ul><ol><li>phase 1 (voting)<br><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/2-phase-commit-1.png" alt="2-phase-commit-1"></li></ol><ul><li>Coordinator向每个participant发送query to commit消息</li><li>每个participant根据本地情况回答yes 或 no</li></ul><ol start="2"><li>phase 2 (completion)<br><img src="//bruceeezhao.github.io/2020/02/19/大数据系统/2-phase-commit-2.png" alt="2-phase-commit-2"></li></ol><ul><li><p>当所有的回答都是yes, transaction 将commit</p></li><li><p>Coordinator向每个participant发送commit消息</p></li><li><p>Participant 回答acknowledgment</p></li><li><p>当至少一个的回答是no, transaction 将abort</p></li><li><p>Coordinator向每个participant发送abort消息</p></li><li><p>Participant 回答acknowledgment</p></li></ul><h4 id="2-9-3-2-崩溃恢复"><a href="#2-9-3-2-崩溃恢复" class="headerlink" title="2.9.3.2. 崩溃恢复"></a>2.9.3.2. 崩溃恢复</h4><ul><li>恢复时日志中可能有下述情况<ul><li>有commit或abort记录：那么分布式事务处理结果已经收到，进行相应的本地commit或abort</li><li>有prepare，而没有commit/abort：那么分布式事务的处理结果未知，需要和prepare记录中的coordinator进行联系</li><li>没有prepare/commit/abort：那么本地abort</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1. 背景&quot;&gt;&lt;/a&gt;1. 背景&lt;/h1&gt;&lt;h2 id=&quot;1-1-大数据概念&quot;&gt;&lt;a href=&quot;#1-1-大数据概念&quot; class=&quot;headerlink&quot; title=&quot;1.1. 大数据概念&quot;&gt;&lt;/a&gt;1.1. 大数据概念&lt;/h2&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>创业基础-1.创业本质与创业思维</title>
    <link href="https://bruceeezhao.github.io/2020/02/18/%E5%88%9B%E4%B8%9A%E5%9F%BA%E7%A1%80-1-%E5%88%9B%E4%B8%9A%E6%9C%AC%E8%B4%A8%E4%B8%8E%E5%88%9B%E4%B8%9A%E6%80%9D%E7%BB%B4/"/>
    <id>https://bruceeezhao.github.io/2020/02/18/创业基础-1-创业本质与创业思维/</id>
    <published>2020-02-18T07:44:53.000Z</published>
    <updated>2020-02-19T12:05:30.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创业活动"><a href="#创业活动" class="headerlink" title="创业活动"></a>创业活动</h1><ol><li>产生创业动机</li><li>识别创业机会—关键环节<ul><li>发现机会</li><li>评价机会价值</li></ul></li><li>整合创业资源</li><li>创建新企业</li><li>实现机会价值</li><li>收获回报</li></ol><a id="more"></a><h1 id="创业的类型"><a href="#创业的类型" class="headerlink" title="创业的类型"></a>创业的类型</h1><p>按照谁在创业，在哪里创业，创业效果如何这三个基本问题，可以将创业分为：</p><ul><li>生存型创业与机会型创业</li><li>个体创业与公司创业</li><li>网络创业</li><li>弱势群体创业和衍生创业</li></ul><h2 id="生存型创业与机会型创业"><a href="#生存型创业与机会型创业" class="headerlink" title="生存型创业与机会型创业"></a>生存型创业与机会型创业</h2><ol><li>生存型创业<br>是指创业行为处于别无其他更好的选择，即不得不参与创业活动解决其面临的困难。<br>例如：下岗工人创业</li><li>机会型创业<br>是指创业行为的动机处于个人抓住现有机会并实现价值的强烈愿望，创业有更好的机会。<br>例如： 李彦宏创立百度</li></ol><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ol><li>创业动机不同</li><li>发现商机市场不同<br>生存型：现有市场中捕捉机会<br>机会型：发现了新需要与新市场</li><li>进入市场不同<br>生存型：面向现有的小市场<br>机会型：面向大市场</li><li>出发点不同</li></ol><h2 id="基于初始条件分类"><a href="#基于初始条件分类" class="headerlink" title="基于初始条件分类"></a>基于初始条件分类</h2><ul><li>边缘型创业</li><li>冒险型创业</li><li>风投支持的创业</li><li>大公司内部的创业</li><li>革命性的创业<br><img src="//bruceeezhao.github.io/2020/02/18/创业基础-1-创业本质与创业思维/relations.png" alt="relations"></li></ul><h2 id="基于效果的分类"><a href="#基于效果的分类" class="headerlink" title="基于效果的分类"></a>基于效果的分类</h2><ul><li>复制型创业</li><li>模仿型创业</li><li>安家型创业</li><li>冒险型创业<br><img src="//bruceeezhao.github.io/2020/02/18/创业基础-1-创业本质与创业思维/result-orinted.png" alt="result-orinted"></li></ul><h1 id="创业逻辑与思维"><a href="#创业逻辑与思维" class="headerlink" title="创业逻辑与思维"></a>创业逻辑与思维</h1><ul><li><p>因果逻辑<br>也被称为预测逻辑，因为它强调必须依靠精确的预测和清洗的目标；</p></li><li><p>效果逻辑<br>也被称为非预测逻辑，极度依靠利益相关这并且是手段导向的。</p></li></ul><h2 id="因果逻辑创业过程"><a href="#因果逻辑创业过程" class="headerlink" title="因果逻辑创业过程"></a>因果逻辑创业过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start=&gt;start: 开展市场研究和竞争分心，找到目标细分市场</span><br><span class="line">operation=&gt;operation: 计算边际成本/价格并制定财务计划</span><br><span class="line">end=&gt;end: 撰写商业计划，整合资源，组建团队并创建新企业</span><br><span class="line"></span><br><span class="line">start-&gt;operation-&gt;end</span><br></pre></td></tr></table></figure><h2 id="效果逻辑创业过程"><a href="#效果逻辑创业过程" class="headerlink" title="效果逻辑创业过程"></a>效果逻辑创业过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start=&gt;start: 从你是谁，你知道什么以及你认识谁开始起步，利用少量资源开始做可以做的事情</span><br><span class="line">operation=&gt;operation: 与大量潜在利益相关者进行交互并谈判实际的投入，根据实际投入重塑创业的具体目标</span><br><span class="line">end=&gt;end: 利益相关者和资源投入链条手链到一个可行的新创企业</span><br><span class="line"></span><br><span class="line">start-&gt;operation-&gt;end</span><br></pre></td></tr></table></figure><h2 id="因果逻辑效果逻辑对比"><a href="#因果逻辑效果逻辑对比" class="headerlink" title="因果逻辑效果逻辑对比"></a>因果逻辑效果逻辑对比</h2><p><img src="//bruceeezhao.github.io/2020/02/18/创业基础-1-创业本质与创业思维/yinguo.png" alt="因果逻辑效果对比"></p><h2 id="创业思维原则"><a href="#创业思维原则" class="headerlink" title="创业思维原则"></a>创业思维原则</h2><p><img src="//bruceeezhao.github.io/2020/02/18/创业基础-1-创业本质与创业思维/principle.png" alt="principle"></p><ol><li>手中鸟原则： 基于你是谁，你知道什么，你认识谁，充分利用自己手中现有的资源开始行动。</li><li>可承受的损失原则： 不要视图追求利益最大化，而是要关注可以承受的损失。</li><li>柠檬原则：不要害怕变化和偶然性，而是要充分利用和拥抱他们。</li><li>疯狂被子原则： 不要进行竞争对手分析，而是要尽可能广泛的建立合作伙伴关系。</li><li>飞行员原则：不要仅仅寻找商机，而是要创造商机。</li></ol><h1 id="精益创业"><a href="#精益创业" class="headerlink" title="精益创业"></a>精益创业</h1><p>核心思想： 以最小化可行产品（Minimal Viable Product， MVP），从每次实验的结果中学习，快速迭代，在资源耗尽之前从迷雾中找到通往成功的道路。</p><h2 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h2><ol><li>确定待验证的假设</li><li>制作MVP</li><li>确定衡量指标，检验假设</li><li>坚持或转型</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    1((学习))--&gt; </span><br><span class="line">    2((想法))--&gt;</span><br><span class="line">    3((开发))--&gt;</span><br><span class="line">    4((编码))--&gt;</span><br><span class="line">    5((测量))--&gt;</span><br><span class="line">    6((数据))--&gt;1</span><br></pre></td></tr></table></figure><h2 id="创业逻辑"><a href="#创业逻辑" class="headerlink" title="创业逻辑"></a>创业逻辑</h2><ol><li>创业初期一系列未经验证的假设</li><li>测试假设（客户开发）<br>邀请潜在的使用者，购买者和合作伙伴提供反馈（产品功能，定价，分销渠道以及可行的客户获取战略）</li><li>敏捷开发方式</li></ol><h2 id="创业思维"><a href="#创业思维" class="headerlink" title="创业思维"></a>创业思维</h2><ol><li>利用手头资源快速行动</li><li>根据可承受损失而不是预期收益采取行动</li><li>小步快走，多次尝试</li><li>在行动中不断吸引更多的人加入</li><li>把行动中的意外事件看成好事</li><li>把激情当成行动的动力</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;创业活动&quot;&gt;&lt;a href=&quot;#创业活动&quot; class=&quot;headerlink&quot; title=&quot;创业活动&quot;&gt;&lt;/a&gt;创业活动&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;产生创业动机&lt;/li&gt;
&lt;li&gt;识别创业机会—关键环节&lt;ul&gt;
&lt;li&gt;发现机会&lt;/li&gt;
&lt;li&gt;评价机会价值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;整合创业资源&lt;/li&gt;
&lt;li&gt;创建新企业&lt;/li&gt;
&lt;li&gt;实现机会价值&lt;/li&gt;
&lt;li&gt;收获回报&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="创业基础" scheme="https://bruceeezhao.github.io/categories/%E5%88%9B%E4%B8%9A%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>区块链技术与应用-以太坊</title>
    <link href="https://bruceeezhao.github.io/2020/02/17/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8-%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    <id>https://bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/</id>
    <published>2020-02-17T08:53:33.000Z</published>
    <updated>2020-03-02T09:09:04.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>以太坊中的出块时间缩短为十几秒，设计了基于gost的协议。以太坊中的mining puzzle是memory hard的，限制了ASIC的使用（ASIC resistance）。  </p><a id="more"></a><p>proof of work –&gt; proof of stake  </p><p>Bitcoin: decentralized currency<br>Ethereum: decentrailized contract(去中心化的合约)  </p><h1 id="2-以太坊账户"><a href="#2-以太坊账户" class="headerlink" title="2. 以太坊账户"></a>2. 以太坊账户</h1><p>基于账户的模型(account-based ledger)  </p><p>有余额的概念，转账交易时只需验证账户上是否有足够的余额，不用验证币的来源，对于double spending attack有天然的防御。  </p><p>缺点： replay attack<br>a向b转10个币，写入区块链中，b又广播一次a向b转账的交易<br>防范： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; B(10 ETH)</span><br><span class="line">  nonce = 21</span><br><span class="line">   singed by A</span><br></pre></td></tr></table></figure><p>nonce 为交易次数，每一个交易的nonce唯一</p><p>以太坊中有两类账户：</p><ul><li><p>外部账户（externally owned account）</p><ul><li>由公私钥对控制</li><li>属性：<br>balance（账户余额）<br>nonce（计数器）</li></ul></li><li><p>合约账户（smart contract account）</p><ul><li>特点：<br>一个合约可以调用其他合约，但合约账户不能主动发起交易</li><li>属性：<br>nonce<br>code<br>storage</li></ul></li></ul><h1 id="3-状态树"><a href="#3-状态树" class="headerlink" title="3. 状态树"></a>3. 状态树</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">为了实现从账户地址到账户状态的映射</span><br><span class="line">addr -&gt; state</span><br><span class="line">160 bits    40个16进制的数</span><br><span class="line">state： 外部账户（balance nonce)</span><br><span class="line">        合约账户（nonce code storage)</span><br></pre></td></tr></table></figure><p>(key, value)<br>RLP:Recursive Length Prefix</p><h2 id="3-1-trie-字典树"><a href="#3-1-trie-字典树" class="headerlink" title="3.1. trie(字典树)"></a>3.1. trie(字典树)</h2><p><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/trie.png" alt="trie"></p><p>特点：</p><ol><li>每个节点的分支数目取决于key值中每个元素的取值范围（在以太坊中分叉数为17，因为是16进制，加上一位结束标志）</li><li>tire的查找效率取决于key的长度，键值越长，查找需要访问内存的次数越多。（在以太坊中key的长度为40）</li><li>不会出现碰撞（只要地址不同就不可能碰撞）</li><li>插入顺序不影响树的结构</li><li>更新的局部性很好，只更新相关的分支</li></ol><p>缺点：</p><ol><li>浪费存储空间</li></ol><h2 id="3-2-Patricia-trie-tree"><a href="#3-2-Patricia-trie-tree" class="headerlink" title="3.2. Patricia trie(tree)"></a>3.2. Patricia trie(tree)</h2><p>为了解决trie的存储浪费，同时提高查找效率，引入了pt  </p><p>pt 是前缀树，对于字典树进行路径压缩。</p><p><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/pt.png" alt="pt"></p><p>注意：<br><strong>在pt中新插入元素，原来压缩的路径可能会扩展开</strong></p><h2 id="3-3-MPT-Merkle-Patricia-tree"><a href="#3-3-MPT-Merkle-Patricia-tree" class="headerlink" title="3.3. MPT(Merkle Patricia tree)"></a>3.3. MPT(Merkle Patricia tree)</h2><p>使用哈希指针的pt  </p><p>以太坊中使用的是 modified MPT<br><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/mpt.png" alt="mpt"></p><p><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/blocks.png" alt="blocks"></p><p>保存历史状态是为了支持回滚操作  </p><p>blockheader代码：<br><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/headcode.png" alt="headcode"></p><p>block代码：<br><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/blockcode.png" alt="blockcode"></p><p>extblock代码：<br><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/extblock.png" alt="ext"></p><h1 id="4-交易树和收据树"><a href="#4-交易树和收据树" class="headerlink" title="4. 交易树和收据树"></a>4. 交易树和收据树</h1><p>对于状态树来说，查找的键值就是账户的地址，对于交易树和收据树来说，查找的键值就是这个交易在发布的区块里的序号，交易的排列顺序是由发布这个区块的节点决定的。  </p><p>区别：  </p><ul><li><p>交易树和收据树是只把当前发布的区块的交易组织起来的；而状态树是把系统中所有账户的状态都要包含进来，不管这个账户与当前的交易有没有关系。</p></li><li><p>每个区块的交易树和收据树都是独立的，他们是不会共享节点的，一个区块和另一个区块发布的交易本身我们也认为是独立的。</p></li></ul><p>作用：</p><ul><li>提供Merkel proof</li><li>查找过去n天产生与某个只能合约相关的交易</li></ul><h2 id="4-1-bloom-filter"><a href="#4-1-bloom-filter" class="headerlink" title="4.1. bloom filter"></a>4.1. bloom filter</h2><p>可以支持高效的查找，判断某个元素是否在某个集合中。<br>思想： 为集合计算出一个紧凑的摘要，哈希映射<br>缺点： </p><ul><li>哈希碰撞（false positive)</li><li>不支持删除操作（哈希碰撞）</li></ul><p>通过bloom filter可以过快速过滤掉无关的区块</p><p><strong>以太坊的运行过程可以看做是一个交易驱动的状态机（transaction-driven state machine)，状态的转换是确定的</strong></p><h1 id="5-GHOST-协议"><a href="#5-GHOST-协议" class="headerlink" title="5. GHOST 协议"></a>5. GHOST 协议</h1><p>在以太坊中出现分叉的情况更为常见<br><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/ghost1.png" alt="ghost1"></p><p>（uncle区块：当一个区块a被挖出时，感知到有相同的区块b被挖出，则b是c的uncle区块）被包含的uncle区块可获得7/8的出块奖励。  </p><p>新区块如果包含一个uncle区块可以获得额外的1/32的出块奖励，一个新区块最多包含2个uncle block。  </p><p>初代ghost协议存在的问题：</p><ul><li>只能包含两个uncle区块</li><li>为了商业竞争，可能故意不包含uncle区块</li></ul><p>修改协议：</p><ul><li>祖父，曾祖父区块。。。都可以作为uncle区块，因为区块不太可能都是由同一个矿池挖出，所以会有其他区块包含uncle区块，使得uncle区块可以获得奖励。</li></ul><p><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/uncle2.png" alt="uncle2"></p><ul><li>以太坊中规定最多可以包含前6代的uncle区块，6代之前的不是uncle区块，或者说合法的uncle只有6个辈分。  </li><li>对于当前块来讲，包含任意辈分的uncle，都能获得额外的1/32的出块奖励。</li></ul><p><strong>以太坊中有两种reward，block reward和gas fee，uncle block不能获得gas fee。gas fee与比特币中的交易费类似。</strong>  </p><p>问题：</p><ol><li><p>包含uncle block时要执行uncle block中的交易吗？<br>不检查uncle block中交易的合法性，值检查uncle是否符合挖矿难度</p></li><li><p>如果分叉之后还跟着一串该怎么办？<br><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/q2.png" alt="q2"><br>如果每个都给奖励，会降低分叉攻击的成本。以太坊中规定只给第一个区块奖励。</p></li></ol><h1 id="6-挖矿算法"><a href="#6-挖矿算法" class="headerlink" title="6. 挖矿算法"></a>6. 挖矿算法</h1><p>挖矿是保证区块链安全的一个重要保障，所以我们可以说block chain is secured by mining.  </p><p>但是比特币的挖矿算法后来出现了ASIC芯片，使得具有强算力的设备在挖矿上有更大的优势，这与去中心化的思想是背道而驰的。（只能专业的机器，普通的计算设备不能参与挖矿）  </p><p>后来出现的加密货币的挖矿算法在设计的时候尽量降低对于ASIC的依赖，增加对内存的需求，即</p><blockquote><p>ASIC resistance<br>memory hard mining puzzle  </p></blockquote><p>LiteCoin 就是基于这种思想的加密货币</p><h2 id="6-1-LiteCoin"><a href="#6-1-LiteCoin" class="headerlink" title="6.1. LiteCoin"></a>6.1. LiteCoin</h2><p>使用基于scrypt的mining puzzle   </p><p><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/litecoin.png" alt="litecoin"></p><p>开设一个很大的数组，按照顺序填充一些伪随机数，使用seed填充第一个值，后一个值是有前一个值取哈希得到的。<br>求解puzzle时，读取A位置的数，根据他的取值算出下一个读取的位置，比如是B，以此类推。  </p><p>问题：</p><ul><li>对于轻节点不友好，验证和求解需要同样的内存</li></ul><p>实际上litecoin的内存只有128k</p><h2 id="6-2-以太坊"><a href="#6-2-以太坊" class="headerlink" title="6.2. 以太坊"></a>6.2. 以太坊</h2><p>以太坊使用memory hard的挖矿算法。</p><ul><li>有两个数据集，小数据集16M cache，大数据集1G dataset(DAG)。大数据集是从小数据集中生成出来的。</li><li>小数据集是轻节点保存的</li><li>大数据集是挖矿节点使用的</li><li>这两个数据集是不断增大的</li></ul><h3 id="6-2-1-伪代码"><a href="#6-2-1-伪代码" class="headerlink" title="6.2.1. 伪代码"></a>6.2.1. 伪代码</h3><p>生成小数据集：<br><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/code-g16m.png" alt="code-16m"></p><p>生成大数据集：<br><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/code-g1g.png" alt="code-1g"><br><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/code-g1gc.png" alt="code-1gc"></p><p>挖矿/验证函数：<br><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/code-m-c.png" alt="code-mining-check"></p><p>挖矿函数：<br><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/code-mine.png" alt="code-mine"></p><p>全部函数：<br><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/code-eth-full.png" alt="code-eth"></p><h2 id="6-3-几点说明"><a href="#6-3-几点说明" class="headerlink" title="6.3. 几点说明"></a>6.3. 几点说明</h2><ol><li><p><strong>以太坊实际上只有gpu挖矿，没有出现ASIC矿机，从这一点上讲是比较成功的。</strong>  </p></li><li><p>以太坊构思从工作量证明转向权益证明，即POW-&gt;POS，但至今没有转变。  </p></li><li><p>以太坊中使用了预挖矿（pre-mining)的过程，所谓预挖矿是指预留一些以太币给开发者。</p></li></ol><h1 id="7-难度调整算法"><a href="#7-难度调整算法" class="headerlink" title="7. 难度调整算法"></a>7. 难度调整算法</h1><p>与比特币的每隔2016个区块调整一次不同，以太坊是每隔区块都有可能调整难度。  </p><p>难度调整算法：<br><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/difficult-c.png" alt="difficult"></p><p><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/difficult-1.png" alt="diffcult-1"></p><p><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/difficult-2.png" alt="diffcult-2"></p><p><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/difficult-e.png" alt="diffcult-e"></p><p>以太坊发展的4个阶段：<br><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/4stage.png" alt="4stage"></p><p>拜占庭阶段调整挖矿难度具体代码实现：<br><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/code-difficult.png" alt="code-difficult"></p><p><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/code-difficult-base.png" alt="code-diffi-base"></p><h1 id="8-权益证明（proof-of-stake"><a href="#8-权益证明（proof-of-stake" class="headerlink" title="8. 权益证明（proof of stake)"></a>8. 权益证明（proof of stake)</h1><p>例如，根据持有币的多少来确定挖矿难度，持有币越多，挖矿难度越低，但这个设计会有问题，因为持有币多的人总会很容易挖到矿。所以有的加密货币要求投入的币会锁定一段时间。有时候叫做proof of deposit。  </p><p>早期的权益证明会遇到两边下注的问题（nothing at stake）<br><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/nothing-at-stake.png" alt="nothing-at-stake"></p><p>在下面分支投入的币不会影响上面分支</p><h2 id="8-1-Casper-the-Friendly-Finality-Gadget-FFG"><a href="#8-1-Casper-the-Friendly-Finality-Gadget-FFG" class="headerlink" title="8.1. Casper the Friendly Finality Gadget(FFG)"></a>8.1. Casper the Friendly Finality Gadget(FFG)</h2><p>以太坊想要使用的权益证明  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">以太坊中引入了一个validator的概念：</span><br><span class="line">validator（验证者）： 要成为一个validator，必须要投入一些以太币作为保证金，这些保证金会被系统锁定</span><br><span class="line"></span><br><span class="line">validator职责：推动系统达成共识，投票决定哪条链是最长合法链，投票的权重取决于投入保证金的多少。</span><br><span class="line"></span><br><span class="line">具体做法类似于数据库中的 two-phase commit,第一轮 prepare message， 第二轮 commit message</span><br><span class="line"></span><br><span class="line">挖矿时每挖出100个区块，就作为一个epoch。 决定其能否作为一个 ，要进行投票。每一轮投票都要得到2/3以上的验证者才能通过。</span><br><span class="line"></span><br><span class="line">在实际中不再区分这两个message，且将100个区块降为50个区块。每个epoch只用一轮投票，这轮投票对于上一个epoch来说是commit message，对于下一个epoch来说是prepare message，连续两轮投票都得到2/3以上的多数，才算有效。</span><br></pre></td></tr></table></figure><p><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/epoch.png" alt="epoch"></p><p>验证者参与这个过程:  </p><ul><li>如果验证者履行职责，可以得到相应的奖励</li><li>如果验证者有不良行为，要受到相应的惩罚<ul><li>行政不作为（该投票不投票），扣除一部分保证金</li><li>乱投票（两边下注），没收保证金（销毁）</li></ul></li><li>每个验证者有一定任期，任期满了之后有一定等待期，在等待期可以接受其他节点检举揭发对其惩处，如果等待期通过，则可以取回保证金和相应的奖励</li></ul><h1 id="9-智能合约"><a href="#9-智能合约" class="headerlink" title="9. 智能合约"></a>9. 智能合约</h1><ul><li>智能合约是运行在区块链上的一段带密码，代码逻辑定义了合约内容</li><li>智能合约的账户保存了合约当前的运行状态<ul><li>balance： 当前余额</li><li>nonce： 交易次数</li><li>code：合约代码</li><li>storage： 存储，数据结构是一颗MPT</li></ul></li><li>Solidity是智能合约最常用的语言，语法上与JavaScript很相近</li></ul><p><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/soliditydemo.png" alt="solidity"></p><h2 id="9-1-如何调用智能合约"><a href="#9-1-如何调用智能合约" class="headerlink" title="9.1. 如何调用智能合约"></a>9.1. 如何调用智能合约</h2><p>调用智能合约与转账类似，例如A转账给B，若B是一个普通账户，则与比特币中的转账是相同的；若B是一个合约账户，这个转账实际上是发起对B合约的一次调用，具体调用的函数是在data域中说明的。</p><h3 id="9-1-1-外部账户调用"><a href="#9-1-1-外部账户调用" class="headerlink" title="9.1.1. 外部账户调用"></a>9.1.1. 外部账户调用</h3><p><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/callIn.png" alt="call"><br>其中：</p><ul><li>TO CONTRACT ADDRESS: 是被调用的合约的地址</li><li>中间一行是调用的参数</li></ul><p>汽油费是给发布这个区块的矿工的，汽油费如果不给的话，矿工不会把这个交易打包进入区块。</p><h3 id="9-1-2-一个合约调用另一个合约"><a href="#9-1-2-一个合约调用另一个合约" class="headerlink" title="9.1.2. 一个合约调用另一个合约"></a>9.1.2. 一个合约调用另一个合约</h3><p><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/call-1.png" alt="call-1"></p><p>由于以太坊中合约账户不能主动发起交易，所以在这个例子中应该还有一个外部账户，调用了合约B。</p><p><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/call-2.png" alt="call-2"><br><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/call-3.png" alt="call-3"></p><h3 id="9-1-3-fallback-函数"><a href="#9-1-3-fallback-函数" class="headerlink" title="9.1.3. fallback 函数"></a>9.1.3. fallback 函数</h3><p><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/fallback.png" alt="fallback"></p><h2 id="9-2-智能合约的创建和运行"><a href="#9-2-智能合约的创建和运行" class="headerlink" title="9.2. 智能合约的创建和运行"></a>9.2. 智能合约的创建和运行</h2><p><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/C&R.png" alt="C&amp;R"></p><h2 id="9-3-汽油费（gas-fee）"><a href="#9-3-汽油费（gas-fee）" class="headerlink" title="9.3. 汽油费（gas fee）"></a>9.3. 汽油费（gas fee）</h2><p><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/gas-fee.png" alt="gas-fee"></p><p>死循环不可解，是一个Halting Problem</p><h2 id="9-4-错误处理"><a href="#9-4-错误处理" class="headerlink" title="9.4. 错误处理"></a>9.4. 错误处理</h2><p><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/error-habdle.png" alt="error"></p><p>如果汽油费不够，则会引起回滚，但是已经消耗的汽油费不退，此举是为了防止恶意节点发起拒绝服务攻击。</p><h2 id="9-5-嵌套调用"><a href="#9-5-嵌套调用" class="headerlink" title="9.5. 嵌套调用"></a>9.5. 嵌套调用</h2><p><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/qiantao.png" alt="qiantao"></p><h2 id="9-6-智能合约可以获得的区块信息"><a href="#9-6-智能合约可以获得的区块信息" class="headerlink" title="9.6. 智能合约可以获得的区块信息"></a>9.6. 智能合约可以获得的区块信息</h2><ul><li>block.blockhash(uint blockNumber) returns (bytes32) : 给定区块的哈希—仅对最近的256个区块有效而不包括当前区块</li><li>block.coinbase(address):挖出当前区块的矿工地址</li><li>block.difficulity(uint):当前区块难度</li><li>block.gaslimit(uint):当前区块gas限额</li><li>block.number(uint):当前区块好</li><li>block.timestamp(uint):自unix epoch起始当前区块以秒计的时间戳。</li></ul><h2 id="9-7-智能合约可以获得的调用信息"><a href="#9-7-智能合约可以获得的调用信息" class="headerlink" title="9.7. 智能合约可以获得的调用信息"></a>9.7. 智能合约可以获得的调用信息</h2><ul><li>msg.data(bytes):完整的calldata</li><li>msg.gas(unit):剩余gas</li><li>msg.sender(address):消息发送者（当前调用）</li><li>msg.sig(bytes4):calldata的前4字节（也就是函数表示服）</li><li>msg.value(uint):随消息发送的wei的数量</li><li>now(uint):目前区块时间戳（block.timestamp)</li><li>tx.gasprice(uint):交易的gas价格</li><li>tx.origin(address):交易发起者（完全的调用链）</li></ul><h2 id="9-8-地址类型"><a href="#9-8-地址类型" class="headerlink" title="9.8. 地址类型"></a>9.8. 地址类型</h2><p><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/addresstype.png" alt="addresstype"></p><h3 id="9-8-1-transfer-vs-send-vs-call"><a href="#9-8-1-transfer-vs-send-vs-call" class="headerlink" title="9.8.1. transfer vs. send vs. call"></a>9.8.1. transfer vs. send vs. call</h3><p>这三个函数都可以用于转账</p><ol><li>transfer和send 这两个是专门为了转账的函数，区别在于，transfer会导致连锁回滚；send不会导致连锁回滚</li><li>call本意是用来调用函数的，也可以转账。也不会连锁回滚。把剩下的汽油都发过去</li></ol><h1 id="10-the-Dao"><a href="#10-the-Dao" class="headerlink" title="10. the Dao"></a>10. the Dao</h1><ul><li><p>DAO(Decentralized Autonomous Organization) 去中心化的自治组织</p><ul><li>建立在代码的基础上的组织， 组织的规章制度写在代码里，通过区块链的共识协议维护规章制度的正常执行</li></ul></li><li><p>DAC(Decentralized Autonomous Corporation)</p></li><li><p><strong>the Dao:</strong> 2016年5月出现的一个致力于众筹投资的组织。使用以太币换取代币，由投入币的多少确定投票资格。收益的取回方式：split Dao，split直到子Dao中只有一个用户。<br><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/thedao.png" alt="the dao"><br>由于代码的漏洞，黑客发动了重入攻击。取走了很多以太币<br>这件事引起了轩然大波，在社区引发了激烈讨论，以太坊开发团队首先试图冻结与the Dao相关的交易，发布软件升级，实现软分叉，但由于升级的代码中不收取与the Dao相关交易的汽油费，导致产生了很多攻击。后又发布另一个版本的升级，实现硬分叉。以太坊分为了两个社区，旧链改为ETC,新链仍使用ETH.</p></li></ul><h2 id="10-1-反思"><a href="#10-1-反思" class="headerlink" title="10.1. 反思"></a>10.1. 反思</h2><ol><li>关于智能合约的反思</li></ol><ul><li><p>Is smart contract really smart?<br>smart contract is anything but smart.</p></li><li><p>Irrerocability is a double edged sword</p></li><li><p>Nothing is irrevovable(不可篡改)</p></li><li><p>Is solidity the right programming language?</p></li></ul><ol start="2"><li><p>what does decentralization mean?<br>对规则的修改需要用去中心化的方式来修改</p></li><li><p>decentralized != distributed</p></li></ol><h1 id="11-美链"><a href="#11-美链" class="headerlink" title="11. 美链"></a>11. 美链</h1><p><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/beautiful-chain.png" alt="beautiflu-chain"></p><p><img src="//bruceeezhao.github.io/2020/02/17/区块链技术与应用-以太坊/batchtransfer.png" alt="batchtransfer"></p><p>当value很大时，amount可能会溢出，会导致体统上凭空出现很多代币。</p><h1 id="12-课程总结"><a href="#12-课程总结" class="headerlink" title="12. 课程总结"></a>12. 课程总结</h1><ul><li>中心化的组织也可以使用去中心化的支付方式</li><li>缺乏一种全球流通的货币</li><li>未来互联网的发展方向：支付渠道和信息渠道的统一</li><li>加密货币不应该与现有货币竞争</li><li>随着协议的改进，支付效率提高了很多</li><li>评价</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;p&gt;以太坊中的出块时间缩短为十几秒，设计了基于gost的协议。以太坊中的mining puzzle是memory hard的，限制了ASIC的使用（ASIC resistance）。  &lt;/p&gt;
    
    </summary>
    
      <category term="区块链技术与应用" scheme="https://bruceeezhao.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="区块链" scheme="https://bruceeezhao.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="以太坊" scheme="https://bruceeezhao.github.io/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>书单</title>
    <link href="https://bruceeezhao.github.io/2020/02/07/%E4%B9%A6%E5%8D%95/"/>
    <id>https://bruceeezhao.github.io/2020/02/07/书单/</id>
    <published>2020-02-07T13:16:24.000Z</published>
    <updated>2020-02-07T13:17:56.332Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>区块链技术与应用-比特币系统</title>
    <link href="https://bruceeezhao.github.io/2020/02/07/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8-%E6%AF%94%E7%89%B9%E5%B8%81%E7%B3%BB%E7%BB%9F/"/>
    <id>https://bruceeezhao.github.io/2020/02/07/区块链技术与应用-比特币系统/</id>
    <published>2020-02-07T08:50:19.000Z</published>
    <updated>2020-02-17T08:55:08.883Z</updated>
    
    <content type="html"><![CDATA[<h1 id="密码学原理"><a href="#密码学原理" class="headerlink" title="密码学原理"></a>密码学原理</h1><h2 id="密码学哈希函数"><a href="#密码学哈希函数" class="headerlink" title="密码学哈希函数"></a>密码学哈希函数</h2><a id="more"></a><p>性质： </p><ol><li><p>collision resistance 很难产生哈希碰撞<br>很难找到一个值 m’ 使得 H(m’) = h(m)</p></li><li><p>hiding 单向<br>x -&gt; H(x)<br>从哈希值h(x)不能反推出x<br>成立前提:输入空间足够大，概率分布较均匀  </p></li></ol><blockquote><p>这两个性质结合可以应用于<br>digital commitment<br>digital equivalent of a sealed envelope</p></blockquote><ol start="3"><li>puzzle friendly 比特币中的哈希函数性质<br>SHA-256<br>difficult to solve,but easy to verify<br>H(block header) &lt;= target</li></ol><h2 id="签名："><a href="#签名：" class="headerlink" title="签名："></a>签名：</h2><p>(public key, private key) 非对称加密体系<br>签名使用私钥，验证使用公钥<br>成立前提：拥有一个好的随机源</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="哈希指针"><a href="#哈希指针" class="headerlink" title="哈希指针"></a>哈希指针</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p -&gt; ____ &lt;- h()</span><br><span class="line">    |    |</span><br><span class="line">    |    |</span><br><span class="line">    |____|</span><br><span class="line">h() 结构体的哈希值</span><br></pre></td></tr></table></figure><p>Block chain is a linked list using hash pointers.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">区块链示意图</span><br><span class="line">     ____    ____    ____    ____ </span><br><span class="line">    |    |  |    |  |    |  |    |</span><br><span class="line">    |    |&lt;-|    |&lt;-|    |&lt;-|h() | </span><br><span class="line">    |____|  |____|  |____|  |____|</span><br><span class="line">    创世纪块                  最近产生的区块</span><br><span class="line"></span><br><span class="line">根据前一个区块取哈希，若前面的区块发生变化，则哈希值不能对应上，可以发现篡改</span><br></pre></td></tr></table></figure><h2 id="Merkle-tree"><a href="#Merkle-tree" class="headerlink" title="Merkle tree"></a>Merkle tree</h2><p>使用哈希指针的二叉树</p><p>最下面一层是数据块（交易块），上面的节点都是哈希指针。只需保存root hash的值，就可以判断整棵树是否被篡改。  </p><p>每个区块分为两部分： block header ,block body<br>block header:记录root hash<br>block body:记录交易列表<br>轻节点：只保存block header</p><p><img src="//bruceeezhao.github.io/2020/02/07/区块链技术与应用-比特币系统/merkletree.png" alt="merkle tree"></p><p>作用：提供merkle proof<br><img src="//bruceeezhao.github.io/2020/02/07/区块链技术与应用-比特币系统/merkleproof.png" alt="merkle proof"></p><p>某个轻节点想证明交易tx是否在merkle tree中，需要向某个全节点发送请求，全节点将标为红色的哈希值告诉轻节点，轻节点即可验证。</p><p>proof of membership  </p><p>当节点按哈希值大小排序时(sorted merkle tree)，是可以证明 nonmembership 的</p><h1 id="数字货币的问题："><a href="#数字货币的问题：" class="headerlink" title="数字货币的问题："></a>数字货币的问题：</h1><ol><li><p>doble spending attack<br>如果数字货币只有签名，那么货币可能被复制  </p><p>中心化的解决方法，央行记录货币的拥有者，交易时验证货币拥有者的信息</p></li></ol><h2 id="去中心化的数字货币要解决的问题："><a href="#去中心化的数字货币要解决的问题：" class="headerlink" title="去中心化的数字货币要解决的问题："></a>去中心化的数字货币要解决的问题：</h2><ol><li>数字货币的发行</li><li>验证交易的有效性</li></ol><p><img src="//bruceeezhao.github.io/2020/02/07/区块链技术与应用-比特币系统/trans.png" alt="trans"></p><p>交易分为输入和输出：输入包括a的公钥和币的来源，输出部分为接收者的公钥<br>在铸币交易时公布了a的公钥  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">block header</span><br><span class="line"> version</span><br><span class="line"> hash of previous block header</span><br><span class="line"> merkle root hash</span><br><span class="line"> target</span><br><span class="line"> nonce</span><br><span class="line"></span><br><span class="line">block body</span><br><span class="line"> transaction list</span><br></pre></td></tr></table></figure><h2 id="Consensus-in-BitCoin"><a href="#Consensus-in-BitCoin" class="headerlink" title="Consensus in BitCoin"></a>Consensus in BitCoin</h2><h1 id="比特币系统的实现"><a href="#比特币系统的实现" class="headerlink" title="比特币系统的实现"></a>比特币系统的实现</h1><h2 id="基于交易的账本"><a href="#基于交易的账本" class="headerlink" title="基于交易的账本"></a>基于交易的账本</h2><p>比特币系统是基于交易的账本，transaction-based ledger  </p><p>比特币的全节点要维护一个utxo的数据结构：Unspent Transaction Output(未花掉的交易的输出的集合)，可以快速检测double spending  </p><p>total inputs = total outputs</p><h2 id="基于账户的账本"><a href="#基于账户的账本" class="headerlink" title="基于账户的账本"></a>基于账户的账本</h2><p>以太坊采用这种模式<br>account-based ledger</p><h2 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h2><p>不断尝试nonce来求解puzzle  </p><p>每次尝试可以看做是一个bernoulli trial:a random experiment with binary outcome  </p><p>berboulli process: a sequence of independent Bernoulli trails  </p><p>性质： memoryless  </p><p>每次的成功概率很小，可以用泊松近似（Poisson process）</p><p>出块时间服从指数分布 x^(-1)  </p><p>比特币的总数为 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">21万*50 + 21万*25 + ....</span><br><span class="line">= 21万 * 50 * (1+1/2+1/4+...) = 2100万</span><br></pre></td></tr></table></figure><p>比特币的稀有性是人为造成的  </p><p>挖矿提供了一种依靠算力投票的有效机制，bitcoin is secured by mining</p><h1 id="比特币网络工作原理"><a href="#比特币网络工作原理" class="headerlink" title="比特币网络工作原理"></a>比特币网络工作原理</h1><p>应用层： bitCoin Block chain<br>网络层： P2P Overlay Network  </p><p>设计原则： simple, robust, but not efficient<br>传播方式： flooding<br>使用 TCP  </p><h2 id="比特币系统挖矿难度的调整"><a href="#比特币系统挖矿难度的调整" class="headerlink" title="比特币系统挖矿难度的调整"></a>比特币系统挖矿难度的调整</h2><p>H(block header) &lt;= target  </p><p>SHA-256  2^256  </p><p>挖矿难度与target成反比<br>difficulty = difficulty_1_target / target  </p><p>比特币系统中规定每隔10分钟出一个区块，每隔2016个区块调整一次难度  </p><p>target = target * [(actual time) / (expected time)]  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="全节点"><a href="#全节点" class="headerlink" title="全节点"></a>全节点</h2><blockquote><p>一直在线<br>在本地硬盘上维护完整的区块链信息<br>在内存中维护UTXO集合，以便快速验证交易的正确性<br>监听比特币网络上的交易信息，验证每个交易的合法性<br>决定哪些交易会被打包到区块里<br>监听别的矿工挖出来的区块，验证其合法性<br>挖矿</p><ul><li>决定沿着哪条链挖下去</li><li>当出现等长的分叉的时候，选择哪一个分叉</li></ul></blockquote><h2 id="轻节点"><a href="#轻节点" class="headerlink" title="轻节点"></a>轻节点</h2><blockquote><p>不是一直在线<br>不用保存整个区块链，只保存每个区块的块头<br>不用保存全部交易，只保存与自己相关的交易<br>无法检验大多数交易的合法性，只能检验与自己相关的交易的合法性<br>无法检验网上发布的区块的正确性<br>可以验证挖矿的难度<br>只能检测哪个是最长链，不知道哪个是最长合法链</p></blockquote><h2 id="挖矿芯片："><a href="#挖矿芯片：" class="headerlink" title="挖矿芯片："></a>挖矿芯片：</h2><p>CPU -&gt; GPU -&gt; ASIC(Applicition Specific Integrated Circuit)  </p><p>一种ASIC只能为一种加密货币挖矿，除非mining puzzle相同（merge mining）</p><h2 id="矿池："><a href="#矿池：" class="headerlink" title="矿池："></a>矿池：</h2><p>一般有两种组织方式  </p><ol><li>集中式（属于同一个机构）</li><li>分布式（属于不同机构）</li></ol><p>一个矿池可以拥有多个矿工，解决收入不稳定的问题，根据工作量进行收入分配  </p><p>工作量证明： 每尝试一次nonce生成一个share（almost vaild block)  </p><p>优点：  </p><ul><li>解决收入不稳定的问题</li></ul><p>缺点：<br>可能会产生51%攻击</p><ul><li>分叉攻击</li><li>Boycott(A账户发起交易，立刻分叉)</li></ul><h1 id="比特币脚本"><a href="#比特币脚本" class="headerlink" title="比特币脚本"></a>比特币脚本</h1><p><img src="//bruceeezhao.github.io/2020/02/07/区块链技术与应用-比特币系统/script.png" alt="script"></p><p>先执行input script再执行output script，如果过程中出现任何错误都认为交易非法。  </p><p>输入输出脚本类型：</p><h2 id="P2PK-Pay-to-Public-Key"><a href="#P2PK-Pay-to-Public-Key" class="headerlink" title="P2PK(Pay to Public Key)"></a>P2PK(Pay to Public Key)</h2><p><strong>input script:</strong><br>  PUSHDATA(sig)</p><p><strong>output script:</strong><br>  PUSGDATA(PubKey)<br>  CHECKSIG</p><hr><p>脚本执行<br>PUSHDATA(sig)<br>PUSHDATA(PubKey)<br>CHECKSIG</p><hr><p>堆栈元素变化：<br>sig -&gt; PubKey,sig -&gt; true</p><h2 id="P2PKH-Pay-to-Public-Key-Hash"><a href="#P2PKH-Pay-to-Public-Key-Hash" class="headerlink" title="P2PKH(Pay to Public Key Hash)"></a>P2PKH(Pay to Public Key Hash)</h2><p><strong>input script:</strong><br>  PUSHDATA(sig)<br>  PUSHDATA(PubKey)  </p><p><strong>output</strong><br>  DUP<br>  HASH160<br>  PUSHDATA(PubKeyHash)<br>  EQUALVERIFY(比较栈顶两个哈希值是否相等)<br>  CHECKSIG  </p><hr><p>脚本执行<br>PUSHDATA(sig)<br>PUSHDATA(PubKey)<br>DUP<br>HASH160<br>PUSHDATA(PubKeyHash)<br>EQUALVERIFY(比较栈顶两个哈希值是否相等)<br>CHECKSIG  </p><hr><p>堆栈元素变化：<br>sig -&gt; pubKey,sig -&gt; pubKey,PubKey,sig -&gt; PubKeyHash,PubKey,sig -&gt; PubKeyHash,PubKeyHash,PubKey,sig -&gt; PubKey,sig -&gt; True</p><h2 id="P2SH-Pay-to-Script-Hash"><a href="#P2SH-Pay-to-Script-Hash" class="headerlink" title="P2SH(Pay to Script Hash)"></a>P2SH(Pay to Script Hash)</h2><p>采用BIP16的方案：<br><strong>input script:</strong><br>  …<br>  PUSHDATA(sig)<br>  …<br>  PUSHDATA(serialized redeemScript)  </p><p><strong>output scrpit:</strong><br>  HASH160<br>  PUSHDATA(redeemScriptHash)<br>  EQUAL  </p><hr><p>进一步说明  </p><ul><li>input script 要给出一些签名（数目不定）及一段序列化的redeemScript。验证分如下两步：</li></ul><ol><li>验证序列化的redeemScript是否与output script中的哈希值匹配</li><li>反序列话并执行redeemScript，验证input script中给出的签名是否正确</li></ol><ul><li>redeemScript 的形式</li></ul><ol><li>P2PK</li><li>P2PKH</li><li>多重签名形式</li></ol><hr><h3 id="用P2SH实现P2PK"><a href="#用P2SH实现P2PK" class="headerlink" title="用P2SH实现P2PK"></a>用P2SH实现P2PK</h3><p><strong>redeemScript:</strong><br>  PUSHDATA(PubKey)<br>  CHECKSIG  </p><p><strong>input script</strong><br>  PUSHDATA(sig)<br>  PUSHDATA(serialized redeemScript)  </p><p><strong>output script</strong><br>  HASH160<br>  PUSHDATA(redeemScriptHash)<br>  EQUAL  </p><p>第一阶段的验证：<br>  PUSHDATA(sig)<br>  PUSHDATA(serialized redeemScript)<br>  HASH160<br>  PUSHDATA(redeemScriptHash)<br>  EQUAL  </p><p>第二阶段的验证：<br>  PUSHDATA(PubKey)<br>  CHECKSIG  </p><h3 id="多重签名"><a href="#多重签名" class="headerlink" title="多重签名"></a>多重签名</h3><p>例如有5个人，使用其中3个签名可以对账户进行操作<br>最早的多重签名，目前已经不推荐使用  </p><p><strong>input script</strong><br>  ×               (此处的x是因为代码中的bug，向栈中压入一个空元素)<br>  PUSHDATA(Sig_1)<br>  PUSHDATA(Sig_2)<br>  …<br>  PUSHDATA(Sig_M)  </p><p><strong>output script</strong><br>  M<br>  PUSHDATA(pubkey_1)<br>  PUSHDATA(pubkey_2)<br>  …<br>  PUSHDATA(pubkey_N)<br>  N<br>  CHECKMULISIG  </p><h3 id="用P2SH实现多重签名"><a href="#用P2SH实现多重签名" class="headerlink" title="用P2SH实现多重签名"></a>用P2SH实现多重签名</h3><p><strong>input script:</strong><br>  ×<br>  PUSHDATA(Sig_1)<br>  PUSHDATA(Sig_2)<br>  …<br>  PUSHDATA(Sig_M)<br>  PUSHDATA(serialized RedeemScript)  </p><p><strong>output script:</strong><br>  HASH160<br>  PUSHDATA(redeemScriptHash)<br>  EQUAL  </p><p><strong>redeemScript:</strong><br>  M<br>  PUSHDATA(pubkey_1)<br>  PUSHDATA(pubkey_2)<br>  …<br>  PUSHDATA(pubkey_N)<br>  N<br>  CHECKMULISIG  </p><hr><p>脚本执行过程：  </p><p>第一阶段：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FALSE </span><br><span class="line">PUSHDATA(Sig_1)  </span><br><span class="line">PUSHDATA(Sig_2)  </span><br><span class="line">PUSHDATA(seriRS)</span><br><span class="line">HASH160  </span><br><span class="line">PUSHDATA(RSH)  </span><br><span class="line">EQUAL</span><br></pre></td></tr></table></figure><p>第二阶段：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">PUSHDATA(pubkey_1)  </span><br><span class="line">PUSHDATA(pubkey_2)  </span><br><span class="line">PUSHDATA(pubkey_3)</span><br><span class="line">3</span><br><span class="line">CHECKMULISIG</span><br></pre></td></tr></table></figure><h2 id="Proof-of-Burn"><a href="#Proof-of-Burn" class="headerlink" title="Proof of Burn"></a>Proof of Burn</h2><ul><li>output script  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RETURN </span><br><span class="line">  [zero or more ops or text]</span><br></pre></td></tr></table></figure></li></ul><p>这种形式的output被称为：<br>  Provably Unspendable/Prunable Outputs</p><ul><li>脚本说明：<br>假如有一个交易的input指向这个output，不论input里的input script如何设计，执行到RETURN命令之后都会直接返回false，不会执行RETURN后面的其他指令，所以这个outpu无法再花出去，其对应的UTXO也就可以被剪枝了，无需保存。</li></ul><h1 id="比特币分叉-fork"><a href="#比特币分叉-fork" class="headerlink" title="比特币分叉(fork)"></a>比特币分叉(fork)</h1><p>成因：  </p><ul><li><p>state fork<br>挖矿时，两个矿工几乎同时发布区块，就会产生一个临时性的分叉  </p><ul><li>forking attack(deliberate fork)</li></ul></li><li><p>protocal fork<br>因为使用不同版本的协议产生的分叉   </p><ul><li>hard fork</li><li>soft fork</li></ul></li></ul><h2 id="hard-fork"><a href="#hard-fork" class="headerlink" title="hard fork"></a>hard fork</h2><p>对比特币协议内容的分歧，例如区块的大小限制  </p><p>假设新节点更新了协议，旧节点没有更新，那么新节点挖出来的区块不被旧节点认可，新节点在新分叉1上挖，旧节点在分叉2上挖，会产生永久的分叉。</p><h2 id="soft-fork"><a href="#soft-fork" class="headerlink" title="soft fork"></a>soft fork</h2><p>对比特币协议添加一些限制，使得原来合法的交易（区块）在新的协议中不合法。  </p><p>假设区块大小由1M改为0.5M，新节点更新了协议，旧节点没有更新，新节点挖出的区块被老节点认可，老节点挖出的区块不被认可，会出现暂时的分叉。  </p><p>实际情况：  </p><ol><li>给之没有用到的域添加新的含义，coinbase</li><li>P2SH</li></ol><h1 id="比特币的匿名性"><a href="#比特币的匿名性" class="headerlink" title="比特币的匿名性"></a>比特币的匿名性</h1><p>假如银行使用化名，其匿名性是比比特币好的。  </p><p>破坏匿名性：  </p><ol><li>不同的账户间能建立联系</li><li>线下交易</li></ol><p>实现匿名性：  </p><ol><li>coin mixing</li></ol><h2 id="零知识证明"><a href="#零知识证明" class="headerlink" title="零知识证明"></a>零知识证明</h2><p>零知识证明是指一方（证明者）向另一方（验证者）证明一个陈述是正确的，而无需透露除该陈述是正确的外的任何信息。  </p><p>例子： 证明这个账户属于我，可以发布签名</p><h2 id="同态隐藏"><a href="#同态隐藏" class="headerlink" title="同态隐藏"></a>同态隐藏</h2><ul><li>如果x,y不同，那么他们的加密函数值E(x), E(y)也不相同</li><li>给定E(x)的值，很难反推出x的值</li><li>给定E(x)和E(y)的值，我们可以和容易的计算出某些关于x,y的加密函数值<ul><li>同态加法： 通过E(x)和E(y)计算出E(x+y)的值</li><li>同态乘法： 通过E(x)和E(y)计算出E(xy)的值</li><li>扩展到多项式</li></ul></li></ul><p>例子：<br>Alice想要想Bob证明她知道一组数x和y使得x+y=7,同时不让Bob知道x和y的具体数值。  </p><p>简单的版本：  </p><ul><li>Alice把E(x)和E(y)的值发给Bob</li><li>Bob通过收到的E(x)和E(y)计算E(x+y)的值</li><li>Bob同时计算E(7)的值，如果E(x+y) = E(7),那么验证通过，否则失败。</li></ul><p>盲签方法：  </p><ul><li>用户A提供SerialNum，银行在不知道SerialNum的情况下返回签名Token，减少A的存款</li><li>用户A把SerialNum和Token交给B完成交易</li><li>用户B拿SerialNum和Token给银行验证，银行验证通过，增加B的存款</li><li>银行无法把A和B联系起来</li><li>中心化</li></ul><h2 id="零币和零钞"><a href="#零币和零钞" class="headerlink" title="零币和零钞"></a>零币和零钞</h2><ul><li>零币和零钞在协议层融合匿名化处理，其匿名属性来自密码学保证</li><li>零币(zerocoin)系统中存在基础币和零币，通过基础币和零币的来回转换，消除旧地址和新地址的关联性，其原理类似于混币服务。</li><li>零钞(zerocash)系统使用zk-SNARKs协议，不依赖一种基础货币，区块链中只记录交易的存在性和矿工用来验证系统正常运行所需要关键属性的证明。区块链上既不显示交易地址也不显示交易金额，所有交易通过零知识验证的方式进行。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;密码学原理&quot;&gt;&lt;a href=&quot;#密码学原理&quot; class=&quot;headerlink&quot; title=&quot;密码学原理&quot;&gt;&lt;/a&gt;密码学原理&lt;/h1&gt;&lt;h2 id=&quot;密码学哈希函数&quot;&gt;&lt;a href=&quot;#密码学哈希函数&quot; class=&quot;headerlink&quot; title=&quot;密码学哈希函数&quot;&gt;&lt;/a&gt;密码学哈希函数&lt;/h2&gt;
    
    </summary>
    
      <category term="区块链技术与应用" scheme="https://bruceeezhao.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="区块链" scheme="https://bruceeezhao.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="比特币" scheme="https://bruceeezhao.github.io/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>rails-admin自定义行为</title>
    <link href="https://bruceeezhao.github.io/2019/12/10/rails-admin%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA/"/>
    <id>https://bruceeezhao.github.io/2019/12/10/rails-admin自定义行为/</id>
    <published>2019-12-10T10:45:48.000Z</published>
    <updated>2020-02-07T12:29:06.139Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<br><a href="http://dmitrypol.github.io/2015/09/10/rails-admin.html" target="_blank" rel="noopener">http://dmitrypol.github.io/2015/09/10/rails-admin.html</a><br><a href="http://fernandomarcelo.com/2012/05/rails-admin-creating-a-custom-action/" target="_blank" rel="noopener">http://fernandomarcelo.com/2012/05/rails-admin-creating-a-custom-action/</a></p><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li><a href="https://stackoverflow.com/questions/2778522/rails-update-attribute-vs-update-attributes" target="_blank" rel="noopener">Rails: update_attribute vs update_attributes</a>  </li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ol><li><p>lib/rails_admin_course_open.rb</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'rails_admin/config/actions'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'rails_admin/config/actions/base'</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">RailsAdminCourseOpen</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">RailsAdmin</span></span></span><br><span class="line">  <span class="class"><span class="keyword">module</span> <span class="title">Config</span></span></span><br><span class="line">    <span class="class"><span class="keyword">module</span> <span class="title">Actions</span></span></span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">CourseOpen</span> &lt; RailsAdmin::Config::<span class="title">Actions::Base</span></span></span><br><span class="line">        <span class="comment"># There are several options that you can set here. </span></span><br><span class="line">        <span class="comment"># Check https://github.com/sferik/rails_admin/blob/master/lib/rails_admin/config/actions/base.rb for more info.</span></span><br><span class="line"> </span><br><span class="line">        register_instance_option <span class="symbol">:bulkable?</span> <span class="keyword">do</span></span><br><span class="line">          <span class="literal">true</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">        register_instance_option <span class="symbol">:controller</span> <span class="keyword">do</span></span><br><span class="line">          Proc.new <span class="keyword">do</span></span><br><span class="line">            <span class="comment"># Get all selected rows</span></span><br><span class="line">            @objects = list_entries(@model_config, <span class="symbol">:destroy</span>)</span><br><span class="line"> </span><br><span class="line">            <span class="comment"># Update field open to true</span></span><br><span class="line">            @objects.each <span class="keyword">do</span> <span class="params">|object|</span></span><br><span class="line">                object.update_attribute(<span class="symbol">:open</span>, <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">            flash[<span class="symbol">:success</span>] = <span class="string">"<span class="subst">#&#123;@model_config.label&#125;</span> successfully opend."</span></span><br><span class="line"> </span><br><span class="line">            redirect_to back_or_index</span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">CourseClose</span> &lt; RailsAdmin::Config::<span class="title">Actions::Base</span></span></span><br><span class="line">        <span class="comment"># There are several options that you can set here. </span></span><br><span class="line">        <span class="comment"># Check https://github.com/sferik/rails_admin/blob/master/lib/rails_admin/config/actions/base.rb for more info.</span></span><br><span class="line"> </span><br><span class="line">        register_instance_option <span class="symbol">:bulkable?</span> <span class="keyword">do</span></span><br><span class="line">          <span class="literal">true</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">        register_instance_option <span class="symbol">:controller</span> <span class="keyword">do</span></span><br><span class="line">          Proc.new <span class="keyword">do</span></span><br><span class="line">            <span class="comment"># Get all selected rows</span></span><br><span class="line">            @objects = list_entries(@model_config, <span class="symbol">:destroy</span>)</span><br><span class="line">            <span class="comment"># Update field open to true</span></span><br><span class="line">            @objects.each <span class="keyword">do</span> <span class="params">|object|</span></span><br><span class="line">                object.update_attribute(<span class="symbol">:open</span>, <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">            flash[<span class="symbol">:success</span>] = <span class="string">"<span class="subst">#&#123;@model_config.label&#125;</span> successfully closed."</span></span><br><span class="line"> </span><br><span class="line">            redirect_to back_or_index</span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>config/initializers/rails_admin.rb  注册</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">RailsAdmin.config <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line">  <span class="comment"># Register the class in lib/rails_admin_publish.rb</span></span><br><span class="line">  <span class="class"><span class="keyword">module</span> <span class="title">RailsAdmin</span></span></span><br><span class="line">    <span class="class"><span class="keyword">module</span> <span class="title">Config</span></span></span><br><span class="line">      <span class="class"><span class="keyword">module</span> <span class="title">Actions</span></span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">CourseOpen</span> &lt; RailsAdmin::Config::<span class="title">Actions::Base</span></span></span><br><span class="line">          RailsAdmin::Config::Actions.register(<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">CourseClose</span> &lt; RailsAdmin::Config::<span class="title">Actions::Base</span></span></span><br><span class="line">          RailsAdmin::Config::Actions.register(<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  config.actions <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># root actions</span></span><br><span class="line">    dashboard                     <span class="comment"># mandatory</span></span><br><span class="line">    <span class="comment"># collection actions</span></span><br><span class="line">    index                         <span class="comment"># mandatory</span></span><br><span class="line">    new</span><br><span class="line">    export</span><br><span class="line">    history_index</span><br><span class="line">    bulk_delete</span><br><span class="line">    <span class="comment"># member actions</span></span><br><span class="line">    show</span><br><span class="line">    edit</span><br><span class="line">    delete</span><br><span class="line">    history_show</span><br><span class="line">    <span class="comment"># show_in_app</span></span><br><span class="line">    course_open <span class="keyword">do</span></span><br><span class="line">      <span class="comment"># Make it visible only for Course model. You can remove this if you don't need.</span></span><br><span class="line">      visible <span class="keyword">do</span></span><br><span class="line">        bindings[<span class="symbol">:abstract_model</span>].model.to_s == <span class="string">"Course"</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    course_close <span class="keyword">do</span></span><br><span class="line">      <span class="comment"># Make it visible only for Course model. You can remove this if you don't need.</span></span><br><span class="line">      visible <span class="keyword">do</span></span><br><span class="line">        bindings[<span class="symbol">:abstract_model</span>].model.to_s == <span class="string">"Course"</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>config/locales/zh-CN.yml</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">actions:</span></span><br><span class="line">     <span class="symbol">course_open:</span></span><br><span class="line">       <span class="symbol">menu:</span> <span class="string">"开启选课"</span></span><br><span class="line">       <span class="symbol">bulk_link:</span> <span class="string">"开启选课%&#123;model_label_plural&#125;"</span></span><br><span class="line">     <span class="symbol">course_close:</span></span><br><span class="line">       <span class="symbol">menu:</span> <span class="string">"关闭选课"</span></span><br><span class="line">       <span class="symbol">bulk_link:</span> <span class="string">"关闭选课%&#123;model_label_plural&#125;"</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;br&gt;&lt;a href=&quot;http://dmitrypol.github.io/2015/09/10/rails-admin.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://dmitrypol.github.io/2015/09/10/rails-admin.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://fernandomarcelo.com/2012/05/rails-admin-creating-a-custom-action/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://fernandomarcelo.com/2012/05/rails-admin-creating-a-custom-action/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>rails使用searchkick和elasticsearch进行全文搜索</title>
    <link href="https://bruceeezhao.github.io/2019/12/10/rails%E4%BD%BF%E7%94%A8searchkick%E5%92%8Celasticsearch%E8%BF%9B%E8%A1%8C%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2/"/>
    <id>https://bruceeezhao.github.io/2019/12/10/rails使用searchkick和elasticsearch进行全文搜索/</id>
    <published>2019-12-10T10:43:04.000Z</published>
    <updated>2020-02-07T12:17:45.411Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<br><a href="https://code.tutsplus.com/articles/full-text-search-in-rails-using-elasticsearch--cms-22920" target="_blank" rel="noopener">https://code.tutsplus.com/articles/full-text-search-in-rails-using-elasticsearch–cms-22920</a><br><a href="https://github.com/ankane/searchkick/blob/v3.1.3/README.md" target="_blank" rel="noopener">https://github.com/ankane/searchkick/blob/v3.1.3/README.md</a></p><a id="more"></a><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><h2 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h2><table><thead><tr><th>软件名称</th><th>版本号</th></tr></thead><tbody><tr><td>rails</td><td>4.2.5.2</td></tr><tr><td>ruby</td><td>2.3.8</td></tr><tr><td>gem</td><td>2.7.7</td></tr><tr><td>bundle</td><td>2.0.2</td></tr><tr><td>searchkick</td><td>3.1.3</td></tr><tr><td>elasticsearch</td><td>5.6.16</td></tr><tr><td>ik</td><td>5.6.16</td></tr></tbody></table><h2 id="选择依据"><a href="#选择依据" class="headerlink" title="选择依据"></a>选择依据</h2><p><img src="//bruceeezhao.github.io/2019/12/10/rails使用searchkick和elasticsearch进行全文搜索/search.png" alt="搜索方式活跃度"><br><a href="https://www.ctolib.com/article/compares/14566" target="_blank" rel="noopener">图片来源</a></p><p>根据上图来看，searchkick在热门度和活跃度上都有不错的表现。  </p><p>以下是主要的搜索gem简介：<a href="https://www.ctolib.com/awesome-rails-gem.html#searchingz" target="_blank" rel="noopener">来源</a></p><ul><li>ransack - Ransack enables the creation of both simple and advanced search forms for your Ruby on Rails application.</li><li>elasticsearch-rails - Elasticsearch integrations for ActiveModel/Record and Ruby on Rails.</li><li>Chewy - High-level Elasticsearch Ruby framework based on the official elasticsearch-ruby client.</li><li>pg_search - pg_search builds ActiveRecord named scopes that take advantage of PostgreSQL’s full text search</li><li>sunspot - Sunspot is a Ruby library for expressive, powerful interaction with the Solr search engine. Sunspot is built on top of the RSolr library, which provides a low-level interface for Solr interaction; Sunspot provides a simple, intuitive, expressive DSL backed by powerful features for indexing objects and searching for them.</li><li>searchkick - Intelligent search made easy with Rails and Elasticsearch.</li></ul><h1 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h1><h2 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h2><p><a href="https://www.elastic.co/cn/downloads/past-releases#elasticsearch" target="_blank" rel="noopener">elasticsearch下载地址</a>  </p><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo dpkg -i elasticsearch-5.6.16.deb</span><br><span class="line"><span class="meta">#</span> 开启服务</span><br><span class="line"><span class="meta">$</span> service elasticsearch start</span><br><span class="line"><span class="meta">#</span> 验证是否启动成功</span><br><span class="line"><span class="meta">$</span> curl 127.0.0.1:9200</span><br><span class="line">&#123;</span><br><span class="line">  "name" : "lCl9Rc9",</span><br><span class="line">  "cluster_name" : "elasticsearch",</span><br><span class="line">  "cluster_uuid" : "HpWOmNyOR0aqA0aZeG3gGA",</span><br><span class="line">  "version" : &#123;</span><br><span class="line">    "number" : "5.6.16",</span><br><span class="line">    "build_hash" : "3a740d1",</span><br><span class="line">    "build_date" : "2019-03-13T15:33:36.565Z",</span><br><span class="line">    "build_snapshot" : false,</span><br><span class="line">    "lucene_version" : "6.6.1"</span><br><span class="line">  &#125;,</span><br><span class="line">  "tagline" : "You Know, for Search"</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span> 看到类似上面的输出则证明服务启动成功</span><br><span class="line"><span class="meta">#</span> 设置服务开机自启</span><br><span class="line"><span class="meta">$</span> systemctl enable elasticsearch.service</span><br></pre></td></tr></table></figure><h2 id="ik插件"><a href="#ik插件" class="headerlink" title="ik插件"></a>ik插件</h2><p>ik插件是elasticsearch中文分词插件<br><a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener">ik插件项目地址</a></p><p>安装:  </p><ol><li>download or compile</li></ol><p><strong>optional 1</strong></p><ul><li>download pre-build package from here: <a href="https://github.com/medcl/elasticsearch-analysis-ik/releases" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik/releases</a></li></ul><p>create plugin folder <code>cd your-es-root/plugins/ &amp;&amp; mkdir ik</code></p><p>unzip plugin to folder <code>your-es-root/plugins/ik</code></p><p><strong>optional 2</strong></p><ul><li>use elasticsearch-plugin to install ( supported from version v5.5.1 ):<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v5.6.16/elasticsearch-analysis-ik-5.6.16.zip</span><br></pre></td></tr></table></figure></li></ul><p><strong>NOTE: replace 5.6.16 to your own elasticsearch version</strong></p><ol start="2"><li>restart elasticsearch</li></ol><h2 id="elasticsearch可视化"><a href="#elasticsearch可视化" class="headerlink" title="elasticsearch可视化"></a>elasticsearch可视化</h2><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ol><li><p>app/models/course.rb</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Course</span> &lt; ActiveRecord::Base</span></span><br><span class="line">  searchkick <span class="symbol">language:</span> <span class="string">"chinese"</span></span><br></pre></td></tr></table></figure></li><li><p>app/helpers/search_helper.rb</p></li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">SearchHelper</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">search</span></span></span><br><span class="line">    <span class="keyword">if</span> params[<span class="symbol">:term</span>] == <span class="string">""</span> <span class="keyword">or</span> params[<span class="symbol">:term</span>].<span class="literal">nil</span>?</span><br><span class="line">      @courses = []</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      term = params[<span class="symbol">:term</span>]</span><br><span class="line"></span><br><span class="line">      <span class="comment"># 搜索，按照短语的方式</span></span><br><span class="line">      <span class="keyword">for</span> res <span class="keyword">in</span> Course.search term, <span class="symbol">highlight:</span> <span class="literal">true</span>, <span class="symbol">match:</span> <span class="symbol">:phrase</span></span><br><span class="line">        @courses &lt;&lt; res</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 分页</span></span><br><span class="line">      @courses = Kaminari.paginate_array(tmp).page(params[<span class="symbol">:page</span>]).per(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> @courses</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>app/views/search/_form.html.erb</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;%= form_for :term, url: list_courses_path, method: :get do |form| %&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    &lt;%= text_field_tag :term, params[:term] %&gt;</span><br><span class="line">    &lt;%= submit_tag &quot;Search&quot;, name: nil %&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;% end %&gt;</span><br></pre></td></tr></table></figure></li><li><p>app/views/courses/list.html.erb</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%= render &apos;search/form&apos; %&gt;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;br&gt;&lt;a href=&quot;https://code.tutsplus.com/articles/full-text-search-in-rails-using-elasticsearch--cms-22920&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://code.tutsplus.com/articles/full-text-search-in-rails-using-elasticsearch–cms-22920&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/ankane/searchkick/blob/v3.1.3/README.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/ankane/searchkick/blob/v3.1.3/README.md&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="rails" scheme="https://bruceeezhao.github.io/categories/rails/"/>
    
    
      <category term="rails" scheme="https://bruceeezhao.github.io/tags/rails/"/>
    
      <category term="searchkick" scheme="https://bruceeezhao.github.io/tags/searchkick/"/>
    
      <category term="elasticsearch" scheme="https://bruceeezhao.github.io/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop Hbase Pseudo-Distributed Local Install 安装记录</title>
    <link href="https://bruceeezhao.github.io/2019/11/27/Hadoop-Hbase-Pseudo-Distributed-Local-Install-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/"/>
    <id>https://bruceeezhao.github.io/2019/11/27/Hadoop-Hbase-Pseudo-Distributed-Local-Install-安装记录/</id>
    <published>2019-11-27T06:24:30.000Z</published>
    <updated>2019-11-27T06:30:27.575Z</updated>
    
    <content type="html"><![CDATA[<p>今天部署了一下hadoop和hbase，期间踩了不少坑。写此文以帮助hadoop、hbase的新手避坑。</p><a id="more"></a><p><strong>不要选择最新的软件</strong><br><strong>不要选择最新的软件</strong><br><strong>不要选择最新的软件</strong><br>重要的事情说三遍</p><h2 id="安装包下载"><a href="#安装包下载" class="headerlink" title="安装包下载"></a>安装包下载</h2><p>jdk: </p><ul><li>版本：jdk-8u191-linux-x64.tar.gz</li><li>网址：wget <a href="http://upyun.qubianzhong.cn/file/java/jdk-8u191-linux-x64.tar.gz" target="_blank" rel="noopener">http://upyun.qubianzhong.cn/file/java/jdk-8u191-linux-x64.tar.gz</a></li><li>来自：<a href="https://cloud.tencent.com/developer/article/1371521" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1371521</a></li></ul><p>hadoop: </p><ul><li>版本：hadoop-2.9.2.tar.gz</li><li>网址：<a href="https://hadoop.apache.org/releases.html" target="_blank" rel="noopener">https://hadoop.apache.org/releases.html</a></li></ul><p>hbase: </p><ul><li>版本：hbase-1.4.9-bin.tar.gz</li><li>网址：<a href="http://hbase.apache.org/downloads.html" target="_blank" rel="noopener">http://hbase.apache.org/downloads.html</a></li></ul><p>百度云：</p><ul><li>链接: <a href="https://pan.baidu.com/s/1z8iX9IxTiYgDNNYp_f5vrA" target="_blank" rel="noopener">https://pan.baidu.com/s/1z8iX9IxTiYgDNNYp_f5vrA</a> </li><li>提取码: 81iu</li></ul><h2 id="jdk"><a href="#jdk" class="headerlink" title="jdk"></a>jdk</h2><p>将压缩包解压放置于你喜欢的目录，并进入该目录，笔者放在了/home/bruce/Software。<br>编辑/etc/profile文件，添加环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/home/bruce/Software/jdk1.8.0_191</span><br><span class="line">export JAR_HOME=$JAVA_HOME/jre</span><br><span class="line"></span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib:$JAR_HOME/lib:$CLASSPATH</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$JAR_HOME/bin</span><br></pre></td></tr></table></figure><h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>首先安装以下软件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install ssh</span><br><span class="line">$ sudo apt-get install rsync</span><br></pre></td></tr></table></figure><h3 id="下载Hadoop："><a href="#下载Hadoop：" class="headerlink" title="下载Hadoop："></a>下载Hadoop：</h3><p>将压缩包解压放置于你喜欢的目录，并进入该目录，笔者放在了/home/bruce/Software。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd hadoop-2.9.2/</span><br></pre></td></tr></table></figure><p>可以在/etc/profile中为hadoop添加环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export Hadoop=/home/bruce/Software/hadoop-2.9.2/bin</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$JAR_HOME/bin:$Hadoop</span><br></pre></td></tr></table></figure><h3 id="修改配置："><a href="#修改配置：" class="headerlink" title="修改配置："></a>修改配置：</h3><p>etc/hadoop/core-site.xml:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>etc/hadoop/hdfs-site.xml:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>修改 etc/hadoop/hadoop-env.sh 文件：<br>在文件末尾加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/home/bruce/Software/jdk1.8.0_191</span><br></pre></td></tr></table></figure><h3 id="配置无密码ssh登录"><a href="#配置无密码ssh登录" class="headerlink" title="配置无密码ssh登录"></a>配置无密码ssh登录</h3><p>确认是否可以无密码登录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh localhost</span><br></pre></td></tr></table></figure><p>若不可以则执行以下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -P &apos;&apos; -f ~/.ssh/id_rsa</span><br><span class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line">chmod 0600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><h3 id="本地运行一个-MapReduce-job"><a href="#本地运行一个-MapReduce-job" class="headerlink" title="本地运行一个 MapReduce job"></a>本地运行一个 MapReduce job</h3><ol><li><p>格式化文件系统</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/hdfs namenode -format</span><br></pre></td></tr></table></figure></li><li><p>Start NameNode daemon and DataNode daemon:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbin/start-dfs.sh</span><br></pre></td></tr></table></figure></li></ol><p>运行完后应该可以访问<a href="http://localhost:50070/" target="_blank" rel="noopener">http://localhost:50070/</a></p><ol start="3"><li><p>Make the HDFS directories required to execute MapReduce jobs:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin/hdfs dfs -mkdir /user</span><br><span class="line">bin/hdfs dfs -mkdir /user/&lt;username&gt;</span><br></pre></td></tr></table></figure></li><li><p>Copy the input files into the distributed filesystem:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/hdfs dfs -put etc/hadoop input</span><br></pre></td></tr></table></figure></li><li><p>Run some of the examples provided:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.9.2.jar grep input output &apos;dfs[a-z.]+&apos;</span><br></pre></td></tr></table></figure></li></ol><p>执行 jps 可以看到以下进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ jps</span><br><span class="line">15975 Jps</span><br><span class="line">15017 NameNode</span><br><span class="line">15389 SecondaryNameNode</span><br><span class="line">15182 DataNode</span><br></pre></td></tr></table></figure><ol start="6"><li>Examine the output files: Copy the output files from the distributed filesystem to the local filesystem and examine them:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin/hdfs dfs -get output output</span><br><span class="line">cat output/*</span><br></pre></td></tr></table></figure><p>成功的话会得到如下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">6dfs.audit.logger</span><br><span class="line">4dfs.class</span><br><span class="line">3dfs.logger</span><br><span class="line">3dfs.server.namenode.</span><br><span class="line">2dfs.audit.log.maxbackupindex</span><br><span class="line">2dfs.period</span><br><span class="line">2dfs.audit.log.maxfilesize</span><br><span class="line">1dfs.log</span><br><span class="line">1dfs.file</span><br><span class="line">1dfs.servers</span><br><span class="line">1dfsadmin</span><br><span class="line">1dfsmetrics.log</span><br><span class="line">1dfs.replication</span><br></pre></td></tr></table></figure><p>or</p><p>View the output files on the distributed filesystem:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/hdfs dfs -cat output/*</span><br></pre></td></tr></table></figure><p>会得到一样的输出</p><h2 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h2><h3 id="下载Hbase"><a href="#下载Hbase" class="headerlink" title="下载Hbase:"></a>下载Hbase:</h3><p>将压缩包解压放置于你喜欢的目录，并进入该目录，笔者放在了/home/bruce/Software。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd hbase-1.4.9/</span><br></pre></td></tr></table></figure><p>可以在/etc/profile中为hbase添加环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export Hbase=/home/bruce/Software/hbase-1.4.9/bin</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$JAR_HOME/bin:$Hadoop:$Hbase</span><br></pre></td></tr></table></figure><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><ol><li><p>编辑 conf/hbase-site.xml 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.rootdir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;hdfs://localhost:9000/hbase&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;/home/hadoop/zookeeper&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li><li><p>编辑 conf/hbase-env.sh 文件<br>在文件末尾加入：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/home/bruce/Software/jdk1.8.0_191</span><br></pre></td></tr></table></figure></li><li><p>启动hbase</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/start-hbase.sh</span><br></pre></td></tr></table></figure></li></ol><p>若启动成功，执行jps会看到一下进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ jps</span><br><span class="line">16503 HMaster</span><br><span class="line">16951 Jps</span><br><span class="line">15017 NameNode</span><br><span class="line">16426 HQuorumPeer</span><br><span class="line">15389 SecondaryNameNode</span><br><span class="line">15182 DataNode</span><br><span class="line">16639 HRegionServer</span><br></pre></td></tr></table></figure><ol start="4"><li>hdfs会自动生成hbase目录<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/hadoop fs -ls /hbase</span><br><span class="line">Found 8 items</span><br><span class="line">drwxr-xr-x   - hadoop supergroup          0 2019-04-23 23:33 /hbase/.tmp</span><br><span class="line">drwxr-xr-x   - hadoop supergroup          0 2019-04-23 23:33 /hbase/MasterProcWALs</span><br><span class="line">drwxr-xr-x   - hadoop supergroup          0 2019-04-23 23:33 /hbase/WALs</span><br><span class="line">drwxr-xr-x   - hadoop supergroup          0 2019-04-23 23:33 /hbase/data</span><br><span class="line">drwxr-xr-x   - hadoop supergroup          0 2019-04-23 23:33 /hbase/hbase</span><br><span class="line">-rw-r--r--   1 hadoop supergroup         42 2019-04-23 23:32 /hbase/hbase.id</span><br><span class="line">-rw-r--r--   1 hadoop supergroup          7 2019-04-23 23:32 /hbase/hbase.version</span><br><span class="line">drwxr-xr-x   - hadoop supergroup          0 2019-04-23 23:34 /hbase/oldWALs</span><br></pre></td></tr></table></figure></li></ol><p>以上操作可以使用root用户进行操作。也可以使用普通用户，若遇到权限问题，可以添加一个hadoop用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#添加用户</span><br><span class="line">sudo addgroup hadoop</span><br><span class="line">sudo adduser -g hadoop hadoop</span><br><span class="line"></span><br><span class="line">#为新用户添加root权限</span><br><span class="line">sudo vim /etc/sudoers </span><br><span class="line">#在文件中添加</span><br><span class="line">hadoop  ALL=(ALL:ALL) ALL</span><br><span class="line"></span><br><span class="line">#改变目录所有权</span><br><span class="line">chown -R hadoop:hadoop hadoop-2.9.2/ </span><br><span class="line">chmod -R 755 hadhbase-1.4.9/</span><br><span class="line"></span><br><span class="line">chown -R hadoop:hadoop hbase-1.4.9/ </span><br><span class="line">chmod -R 755 hbase-1.4.9/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天部署了一下hadoop和hbase，期间踩了不少坑。写此文以帮助hadoop、hbase的新手避坑。&lt;/p&gt;
    
    </summary>
    
      <category term="环境部署" scheme="https://bruceeezhao.github.io/categories/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="hadoop" scheme="https://bruceeezhao.github.io/tags/hadoop/"/>
    
      <category term="hbase" scheme="https://bruceeezhao.github.io/tags/hbase/"/>
    
  </entry>
  
  <entry>
    <title>ruby on rails环境搭建</title>
    <link href="https://bruceeezhao.github.io/2019/11/25/ruby-on-rails%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://bruceeezhao.github.io/2019/11/25/ruby-on-rails环境搭建/</id>
    <published>2019-11-25T06:23:42.000Z</published>
    <updated>2019-11-27T08:52:11.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装ruby"><a href="#安装ruby" class="headerlink" title="安装ruby"></a>安装ruby</h1><p>ruby 存在很多版本，不同的项目可能会使用不同版本的ruby，不同的版本往往有很多不同的依赖使得项目不能运行，因此我们应该考虑到在计算机上管理多个不同版本的ruby。这里我们选用rvm作为ruby的版本管理软件。</p><a id="more"></a><h2 id="安装rvm"><a href="#安装rvm" class="headerlink" title="安装rvm"></a>安装rvm</h2><ul><li><p>install GPG keys</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gpg2 --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB</span><br></pre></td></tr></table></figure></li><li><p>install RVM </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ \curl -sSL https://get.rvm.io | bash -s stable</span><br></pre></td></tr></table></figure></li></ul><p>修改shell为login shell<br>Edit–&gt;Profile Preference–&gt;Command</p><p><img src="//bruceeezhao.github.io/2019/11/25/ruby-on-rails环境搭建/run_command_as_login.png" alt="本地图片"></p><p>修改后关闭此终端，打开一个新的终端继续下面的操作。</p><h2 id="使用rvm管理ruby版本"><a href="#使用rvm管理ruby版本" class="headerlink" title="使用rvm管理ruby版本"></a>使用rvm管理ruby版本</h2><p>在终端中输入  rvm list known 你将会看到如下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ rvm list known</span><br><span class="line"># MRI Rubies</span><br><span class="line">[ruby-]1.8.6[-p420]</span><br><span class="line">[ruby-]1.8.7[-head] # security released on head</span><br><span class="line">[ruby-]1.9.1[-p431]</span><br><span class="line">[ruby-]1.9.2[-p330]</span><br><span class="line">[ruby-]1.9.3[-p551]</span><br><span class="line">[ruby-]2.0.0[-p648]</span><br><span class="line">[ruby-]2.1[.10]</span><br><span class="line">[ruby-]2.2[.10]</span><br><span class="line">[ruby-]2.3[.8]</span><br><span class="line">[ruby-]2.4[.6]</span><br><span class="line">[ruby-]2.5[.5]</span><br><span class="line">[ruby-]2.6[.3]</span><br><span class="line">[ruby-]2.7[.0-preview1]</span><br><span class="line">ruby-head</span><br></pre></td></tr></table></figure><p>上面的信息告诉你有哪些版本是可用的，下面你可以选择你需要的版本进行下载：<br>例如你需要2.3版本的ruby，输入如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm install 2.3</span><br></pre></td></tr></table></figure><p>使用 <strong>rvm list</strong> 命令可以看出你已经安装的ruby版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ rvm list </span><br><span class="line">=* ruby-2.3.8 [ x86_64 ]</span><br><span class="line">   ruby-2.6.3 [ x86_64 ]</span><br><span class="line"></span><br><span class="line"># =&gt; - current</span><br><span class="line"># =* - current &amp;&amp; default</span><br><span class="line">#  * - default</span><br></pre></td></tr></table></figure><p>上面的信息说明在我的系统中安装了2.3 和 2.6 两个版本，当前使用的是2.3版本，且是默认版本。 </p><p>如果我想使用2.6的版本我需要做什么呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ rvm use 2.6</span><br><span class="line">Using /home/bruce/.rvm/gems/ruby-2.6.3</span><br><span class="line">$ rvm list</span><br><span class="line"> * ruby-2.3.8 [ x86_64 ]</span><br><span class="line">=&gt; ruby-2.6.3 [ x86_64 ]</span><br><span class="line"></span><br><span class="line"># =&gt; - current</span><br><span class="line"># =* - current &amp;&amp; default</span><br><span class="line">#  * - default</span><br><span class="line"></span><br><span class="line">$ ruby -v</span><br><span class="line">ruby 2.6.3p62 (2019-04-16 revision 67580) [x86_64-linux]</span><br></pre></td></tr></table></figure><p>可以看到我们已经切换到2.6版本了。<br>更多rvm操作 <a href="http://rvm.io/rvm" target="_blank" rel="noopener">http://rvm.io/rvm</a></p><h2 id="使用gemset"><a href="#使用gemset" class="headerlink" title="使用gemset"></a>使用gemset</h2><p>gemset 为gem安装的插件提供一个独立的空间，可以创建多个gemset以满足不同项目的需求，减少不同项目之间的依赖冲突。</p><ul><li><p>创建gemset</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm gemset create rails2.6</span><br></pre></td></tr></table></figure></li><li><p>使用创建的gemset</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rvm use 2.6@rails2.6</span><br><span class="line">Using /home/bruce/.rvm/gems/ruby-2.6.3 with gemset rails2.6</span><br></pre></td></tr></table></figure></li><li><p>列出系统内gemset</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ rvm gemset list</span><br><span class="line"></span><br><span class="line">gemsets for ruby-2.6.3 (found in /home/bruce/.rvm/gems/ruby-2.6.3)</span><br><span class="line">   (default)</span><br><span class="line">   global</span><br><span class="line">=&gt; rails2.6</span><br></pre></td></tr></table></figure></li></ul><p>更多gemset操作： <a href="http://rvm.io/gemsets" target="_blank" rel="noopener">http://rvm.io/gemsets</a></p><h1 id="更换源"><a href="#更换源" class="headerlink" title="更换源"></a>更换源</h1><h2 id="gem-更换国内源"><a href="#gem-更换国内源" class="headerlink" title="gem 更换国内源"></a>gem 更换国内源</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/</span><br><span class="line"><span class="meta">$</span> gem sources -l</span><br><span class="line">https://gems.ruby-china.com</span><br><span class="line"><span class="meta">#</span> 确保只有 gems.ruby-china.com</span><br></pre></td></tr></table></figure><p>bundle </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> bundle config mirror.https://rubygems.org https://gems.ruby-china.com</span><br></pre></td></tr></table></figure><h1 id="安装yarn"><a href="#安装yarn" class="headerlink" title="安装yarn"></a>安装yarn</h1><p><a href="https://yarn.bootcss.com/docs/install/#debian-stable" target="_blank" rel="noopener">https://yarn.bootcss.com/docs/install/#debian-stable</a></p><p>yarn 更换国内源<br>yarn config set registry <a href="https://registry.npm.taobao.org/" target="_blank" rel="noopener">https://registry.npm.taobao.org/</a></p><h1 id="安装rails"><a href="#安装rails" class="headerlink" title="安装rails"></a>安装rails</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install rails</span><br></pre></td></tr></table></figure><h1 id="ruby-交互式编程"><a href="#ruby-交互式编程" class="headerlink" title="ruby 交互式编程"></a>ruby 交互式编程</h1><p>irb 是ruby自带的交互式变成工具<br>pry 的体验要好于irb</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install pry</span><br></pre></td></tr></table></figure><h1 id="gem-版本降级"><a href="#gem-版本降级" class="headerlink" title="gem 版本降级"></a>gem 版本降级</h1><p>gem版本过高会下载比较新的gem包，会发生依赖冲突，故可以降低gem的版本，使用下面的命令可以安装制定版本的gem</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem update --system 2.7.7</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安装ruby&quot;&gt;&lt;a href=&quot;#安装ruby&quot; class=&quot;headerlink&quot; title=&quot;安装ruby&quot;&gt;&lt;/a&gt;安装ruby&lt;/h1&gt;&lt;p&gt;ruby 存在很多版本，不同的项目可能会使用不同版本的ruby，不同的版本往往有很多不同的依赖使得项目不能运行，因此我们应该考虑到在计算机上管理多个不同版本的ruby。这里我们选用rvm作为ruby的版本管理软件。&lt;/p&gt;
    
    </summary>
    
      <category term="环境部署" scheme="https://bruceeezhao.github.io/categories/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="ruby" scheme="https://bruceeezhao.github.io/tags/ruby/"/>
    
  </entry>
  
  <entry>
    <title>Python操作Access数据库</title>
    <link href="https://bruceeezhao.github.io/2019/06/05/Python%E6%93%8D%E4%BD%9CAccess%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://bruceeezhao.github.io/2019/06/05/Python操作Access数据库/</id>
    <published>2019-06-05T14:00:17.000Z</published>
    <updated>2019-11-25T07:18:57.006Z</updated>
    
    <content type="html"><![CDATA[<p>说明：建立两个连接是因为，只使用一个连接时会出现以下错误：<br>[24000] [Microsoft][ODBC Microsoft Access Driver]Invalid cursor state  (43) (SQLExecDirectW)  </p><a id="more"></a><h2 id="例程1"><a href="#例程1" class="headerlink" title="例程1"></a>例程1</h2><p>以下是测试代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyodbc</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DBfile = <span class="string">r"C:\Users\eagle\Desktop\Database21.accdb"</span>  <span class="comment"># 数据库文件</span></span><br><span class="line">conn = pyodbc.connect(<span class="string">r"Driver=&#123;Microsoft Access Driver (*.mdb, *.accdb)&#125;;DBQ="</span> + DBfile + <span class="string">";Uid=;Pwd=;"</span>)</span><br><span class="line">conn1 = pyodbc.connect(<span class="string">r"Driver=&#123;Microsoft Access Driver (*.mdb, *.accdb)&#125;;DBQ="</span> + DBfile + <span class="string">";Uid=;Pwd=;"</span>) </span><br><span class="line">cursor = conn.cursor()</span><br><span class="line">cursor1 = conn1.cursor()</span><br><span class="line"></span><br><span class="line">TABLE = <span class="string">'xuesheng'</span></span><br><span class="line"></span><br><span class="line">SQL = <span class="string">"delete * from %s;"</span> % TABLE</span><br><span class="line">cursor.execute(SQL)</span><br><span class="line">cursor.commit()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">()</span>:</span></span><br><span class="line">    name_base = <span class="string">'zhang'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">100000</span>):</span><br><span class="line">        ID = i</span><br><span class="line">        name = name_base + str(i)</span><br><span class="line">        age = random.randint(<span class="number">20</span>,<span class="number">26</span>)</span><br><span class="line">        sex = <span class="string">'fmale'</span> <span class="keyword">if</span> (age % <span class="number">2</span>) == <span class="number">0</span>  <span class="keyword">else</span> <span class="string">'male'</span> </span><br><span class="line">        chinese = random.randint(<span class="number">0</span>,<span class="number">100</span>)</span><br><span class="line">        eng = random.randint(<span class="number">0</span>,<span class="number">100</span>)</span><br><span class="line">        math = random.randint(<span class="number">0</span>,<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">        SQL = <span class="string">"insert into %s values(%d, '%s', %d, '%s', %d, %d, %d) ;"</span> \</span><br><span class="line">            % (TABLE, ID, name, age, sex, chinese, eng, math)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cursor1.execute(SQL)</span><br><span class="line">            cursor1.commit()</span><br><span class="line">            <span class="comment">#print(SQL)</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(<span class="string">'write ERROR: %s'</span> %e)</span><br><span class="line">            </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line">        SQL = <span class="string">"SELECT * from %s;"</span> % TABLE</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cursor.execute(SQL)</span><br><span class="line">            <span class="comment">#for row in cursor.execute(SQL):</span></span><br><span class="line">                <span class="comment">#print (row)</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(<span class="string">'read ERROR:%s'</span> %e)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        </span><br><span class="line">w = threading.Thread(target=write,args=())</span><br><span class="line">w.setDaemon(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">r = threading.Thread(target=read,args=())</span><br><span class="line">r.setDaemon(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">w.start()</span><br><span class="line">r.start()</span><br><span class="line"></span><br><span class="line">w.join()</span><br><span class="line">r.join()</span><br><span class="line"></span><br><span class="line">SQL = <span class="string">"select count(*) from %s;"</span> % TABLE</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> cursor.execute(SQL):</span><br><span class="line">    print(row)</span><br><span class="line"></span><br><span class="line">cursor.commit()</span><br><span class="line">cursor.close()</span><br><span class="line">conn.close()</span><br><span class="line">conn1.close()</span><br></pre></td></tr></table></figure><h2 id="例程2"><a href="#例程2" class="headerlink" title="例程2"></a>例程2</h2><p>该例程完成access数据库的复制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyodbc</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> getopt</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.DEBUG,</span><br><span class="line">                format=<span class="string">'%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s'</span>,</span><br><span class="line">                datefmt=<span class="string">'%a, %d %b %Y %H:%M:%S'</span>,</span><br><span class="line">                filename=<span class="string">'access_copy.log'</span>,</span><br><span class="line">                filemode=<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">SourceDatabase = <span class="literal">None</span></span><br><span class="line">SourceTable = <span class="literal">None</span></span><br><span class="line">DestDatabase = <span class="literal">None</span></span><br><span class="line">DestTable = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># connection and cursor</span></span><br><span class="line">conn_s = <span class="literal">None</span></span><br><span class="line">cursor_s = <span class="literal">None</span></span><br><span class="line">conn_d = <span class="literal">None</span></span><br><span class="line">cursor_d = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(row)</span>:</span></span><br><span class="line">    error = <span class="number">0</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        SQL = <span class="string">"insert into %s values %s"</span> \</span><br><span class="line">            %(DestTable, row)</span><br><span class="line">        logging.info(SQL)</span><br><span class="line">        cursor_d.execute(SQL)</span><br><span class="line">        cursor_d.commit()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">if</span> re.search(<span class="string">'duplicate data'</span>, e):</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            logging.error(<span class="string">"write to %s error: %s"</span> %(DestTable, e))</span><br><span class="line">            error = <span class="number">1</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">return</span> error</span><br><span class="line">            </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(line)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        SQL = <span class="string">"SELECT top %d * from %s;"</span> % (line, SourceTable)</span><br><span class="line">        logging.info(SQL)</span><br><span class="line">        rows = cursor_s.execute(SQL).fetchall()</span><br><span class="line">        <span class="keyword">return</span> rows</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logging.error(<span class="string">'read from %s error: %s'</span>%(SourceTable, e))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#count the dest table,decide the place begin to copy</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_s</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        SQL = <span class="string">"SELECT count(*) from %s;"</span> % SourceTable</span><br><span class="line">        lines = cursor_s.execute(SQL).fetchone()</span><br><span class="line">        logging.info(<span class="string">'%s %s count is %d'</span> %(SourceDatabase, SourceTable, lines[<span class="number">0</span>]))</span><br><span class="line">        <span class="keyword">return</span> lines</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logging.error(e)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_d</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        SQL = <span class="string">"SELECT count(*) from %s;"</span> % DestTable</span><br><span class="line">        lines = cursor_d.execute(SQL).fetchone()</span><br><span class="line">        logging.info(<span class="string">'%s %s count is %d'</span> %(DestDatabase, DestTable, lines[<span class="number">0</span>]))</span><br><span class="line">        <span class="keyword">return</span> lines</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logging.error(e)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">databaseCopy</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> conn_s</span><br><span class="line">    <span class="keyword">global</span> conn_d</span><br><span class="line">    <span class="keyword">global</span> cursor_s</span><br><span class="line">    <span class="keyword">global</span> cursor_d</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        conn_s = pyodbc.connect(<span class="string">r"Driver=&#123;Microsoft Access Driver (*.mdb, *.accdb)&#125;;DBQ="</span> + SourceDatabase + <span class="string">";Uid=;Pwd=;"</span>)</span><br><span class="line">        conn_d = pyodbc.connect(<span class="string">r"Driver=&#123;Microsoft Access Driver (*.mdb, *.accdb)&#125;;DBQ="</span> + DestDatabase + <span class="string">";Uid=;Pwd=;"</span>) </span><br><span class="line">        cursor_s = conn_s.cursor()</span><br><span class="line">        cursor_d = conn_d.cursor()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        lines_s = count_s()</span><br><span class="line">        <span class="keyword">if</span>(lines_s == <span class="literal">None</span>):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        lines_d = count_d()</span><br><span class="line">        <span class="keyword">if</span>(lines_d == <span class="literal">None</span>):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        rows = read(lines_s[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span>(rows == <span class="literal">None</span>):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lines_s == lines_d):</span><br><span class="line">            logging.info(<span class="string">'source database %s table %s not change, no need to copy'</span> %(SourceDatabase ,SourceTable))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            logging.info(<span class="string">'rows: %d'</span> % len(rows))</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, lines_s[<span class="number">0</span>]<span class="number">-1</span>):</span><br><span class="line">                error = write(rows[i])</span><br><span class="line">                <span class="keyword">if</span> error:</span><br><span class="line">                    logging.info(<span class="string">'rows:%d  %s'</span> %(i, rows[i]))</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logging.error(e)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> SourceDatabase</span><br><span class="line">    <span class="keyword">global</span> SourceTable</span><br><span class="line">    <span class="keyword">global</span> DestDatabase</span><br><span class="line">    <span class="keyword">global</span> DestTable</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        opts, args = getopt.getopt(sys.argv[<span class="number">1</span>:],<span class="string">"h"</span>,[<span class="string">"help"</span>,<span class="string">"sd="</span>,<span class="string">"st="</span>,<span class="string">"dd="</span>, <span class="string">"dt="</span>])</span><br><span class="line">    <span class="keyword">except</span> getopt.GetoptError <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">        help()</span><br><span class="line">        sys.exit(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> opt, arg <span class="keyword">in</span> opts:</span><br><span class="line">        <span class="keyword">if</span> opt <span class="keyword">in</span> (<span class="string">'-h'</span>, <span class="string">'--help'</span>):</span><br><span class="line">            help()</span><br><span class="line">            sys.exit()</span><br><span class="line">        <span class="keyword">elif</span> opt == <span class="string">'--sd'</span>:</span><br><span class="line">            SourceDatabase = arg</span><br><span class="line">        <span class="keyword">elif</span> opt == <span class="string">'--st'</span>:</span><br><span class="line">            SourceTable = arg</span><br><span class="line">        <span class="keyword">elif</span> opt == <span class="string">'--dd'</span>:</span><br><span class="line">            DestDatabase = arg</span><br><span class="line">        <span class="keyword">elif</span> opt == <span class="string">'--dt'</span>:</span><br><span class="line">            DestTable = arg</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            print(<span class="string">'error %s %s'</span> %(opt, arg) )</span><br><span class="line">            help()</span><br><span class="line">            sys.exit(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (SourceDatabase  <span class="keyword">and</span> SourceTable <span class="keyword">and</span> DestDatabase <span class="keyword">and</span> DestTable):</span><br><span class="line">        databaseCopy()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'some empty %s %s %s %s'</span> % (SourceDatabase, SourceTable, DestDatabase, DestTable))</span><br><span class="line">        help()</span><br><span class="line">        sys.exit(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    count_s()</span><br><span class="line">    count_d()</span><br><span class="line">    conn_s.close()</span><br><span class="line">    conn_d.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">help</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'---------------------------------'</span>)</span><br><span class="line">    print(<span class="string">'usage:'</span>)</span><br><span class="line">    print(<span class="string">'help: %s -h'</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">    print(<span class="string">'%s --sd=&lt;SourceDatabase&gt; --st=&lt;SourceTable&gt; --dd=&lt;DestDatabase&gt; --dt=&lt;DestTable&gt;'</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>使用方法：<br>可以将下面的代码保存为bat文件，自行替换 –sd –st –dd –dt 的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python access_copy.py --sd=&quot;\\192.168.1.112\Users\eagle\Desktop\Database31.accdb&quot; --st=xuesheng --dd=&quot;C:\Users\eagle\Desktop\Database31.accdb&quot; --dt=xuesheng</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>access数据库的复制支持通过共享文件夹的方式读取远程的数据库。  </li></ul><h2 id="access-数据库的问题："><a href="#access-数据库的问题：" class="headerlink" title="access 数据库的问题："></a>access 数据库的问题：</h2><p>假设程序A对A数据库执行写入操作，程序B读取A数据库中的数据写入B库。  </p><ol><li>如果执行select*那么程序会一直写入，直到A库的写操作完成。</li><li>如果想写入程序执行时A数据库的数据的条数，需加上top限制，但是不能保证读出数据的次序。</li><li>加上 order by 后会死等，直到程序A的写操作完成，B程序才开始执行写操作。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说明：建立两个连接是因为，只使用一个连接时会出现以下错误：&lt;br&gt;[24000] [Microsoft][ODBC Microsoft Access Driver]Invalid cursor state  (43) (SQLExecDirectW)  &lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://bruceeezhao.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://bruceeezhao.github.io/tags/Python/"/>
    
      <category term="Access数据库" scheme="https://bruceeezhao.github.io/tags/Access%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
